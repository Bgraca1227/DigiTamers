<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Digimon RPG">
  <meta name="theme-color" content="#0a0f1e">
  <title>Digimon Rogue-like RPG</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Exo+2:wght@300;400;500;600;700&display=swap" rel="stylesheet">
  <style>
    /* Premium Design System */
    :root {
      /* Color Palette */
      --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --secondary-gradient: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
      --dark-gradient: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
      --glass-bg: rgba(255, 255, 255, 0.05);
      --glass-border: rgba(255, 255, 255, 0.1);
      --accent-blue: #00d4ff;
      --accent-purple: #8b5cf6;
      --accent-gold: #fbbf24;
      --text-primary: rgba(255, 255, 255, 0.95);
      --text-secondary: rgba(255, 255, 255, 0.7);
      --text-muted: rgba(255, 255, 255, 0.5);
      
      /* Shadows */
      --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.15);
      --shadow-md: 0 8px 32px rgba(0, 0, 0, 0.25);
      --shadow-lg: 0 16px 64px rgba(0, 0, 0, 0.4);
      --shadow-glow: 0 0 30px rgba(103, 126, 234, 0.3);
      
      /* Spacing */
      --space-xs: 0.5rem;
      --space-sm: 1rem;
      --space-md: 1.5rem;
      --space-lg: 2rem;
      --space-xl: 3rem;
      
      /* Border Radius */
      --radius-sm: 8px;
      --radius-md: 16px;
      --radius-lg: 24px;
      --radius-xl: 32px;
      
      /* Typography */
      --font-primary: 'Orbitron', monospace;
      --font-secondary: 'Exo 2', sans-serif;
      
      /* Safe Area */
      --safe-top: env(safe-area-inset-top);
      --safe-bottom: env(safe-area-inset-bottom);
      --safe-left: env(safe-area-inset-left);
      --safe-right: env(safe-area-inset-right);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }
    
    html {
      height: 100vh;
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden;
    }
    
    body {
      width: 100vw;
      height: 100vh;
      height: calc(var(--vh, 1vh) * 100);
      background: var(--dark-gradient);
      color: var(--text-primary);
      font-family: var(--font-secondary);
      overflow: hidden;
      position: fixed;
      top: 0;
      left: 0;
      
      /* Padding for iPhone safe areas */
      padding-top: var(--safe-top);
      padding-bottom: var(--safe-bottom);
      padding-left: var(--safe-left);
      padding-right: var(--safe-right);
    }

    /* Mobile viewport height fix */
    @supports (-webkit-touch-callout: none) {
      body {
        height: -webkit-fill-available;
      }
    }
    
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      background: var(--dark-gradient);
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* Glassmorphism Base */
    .glass {
      background: var(--glass-bg);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border: 1px solid var(--glass-border);
      box-shadow: var(--shadow-md);
    }

    .glass-intense {
      background: rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(40px) saturate(200%);
      -webkit-backdrop-filter: blur(40px) saturate(200%);
      border: 1px solid rgba(255, 255, 255, 0.15);
      box-shadow: var(--shadow-lg);
    }
    
    /* Premium Scrollables */
    .scrollable {
      overflow-y: auto;
      overflow-x: hidden;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }
    
    .scrollable::-webkit-scrollbar {
      display: none;
    }
    
    /* Custom scrollbar for desktop */
    @media (min-width: 768px) {
      .scrollable {
        scrollbar-width: thin;
        scrollbar-color: var(--accent-purple) transparent;
      }
      
      .scrollable::-webkit-scrollbar {
        display: block;
        width: 6px;
      }
      
      .scrollable::-webkit-scrollbar-track {
        background: transparent;
      }
      
      .scrollable::-webkit-scrollbar-thumb {
        background: var(--primary-gradient);
        border-radius: 10px;
        border: 2px solid transparent;
        background-clip: content-box;
      }
      
      .scrollable::-webkit-scrollbar-thumb:hover {
        background: var(--secondary-gradient);
        background-clip: content-box;
      }
    }

    /* Premium Button System */
    .digimon-btn {
      position: relative;
      background: var(--primary-gradient);
      border: none;
      border-radius: var(--radius-md);
      color: var(--text-primary);
      padding: var(--space-sm) var(--space-md);
      margin: var(--space-xs);
      cursor: pointer;
      font-family: var(--font-primary);
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.5px;
      text-transform: uppercase;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      box-shadow: var(--shadow-md);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
      min-height: 44px; /* Touch-friendly */
    }

    .digimon-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
      transition: left 0.6s ease;
    }

    .digimon-btn:hover::before {
      left: 100%;
    }

    .digimon-btn:hover {
      transform: translateY(-3px) scale(1.02);
      box-shadow: var(--shadow-lg), var(--shadow-glow);
    }

    .digimon-btn:active {
      transform: translateY(-1px) scale(0.98);
      box-shadow: var(--shadow-sm);
    }

    .digimon-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    /* Button Variants */
    .btn-secondary {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
    }

    .btn-danger {
      background: var(--secondary-gradient);
    }

    .btn-accent {
      background: linear-gradient(135deg, var(--accent-gold), #f59e0b);
    }
    
    /* Premium Panels */
    .panel {
      position: absolute;
      top: 0; 
      left: 0;
      width: 100%; 
      height: 100%;
      background: var(--dark-gradient);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 10;
      padding: var(--space-lg);
      overflow-y: auto;
      
      /* Animated background */
      background-image: 
        radial-gradient(circle at 25% 25%, rgba(103, 126, 234, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 75% 75%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 50% 50%, rgba(0, 212, 255, 0.05) 0%, transparent 50%);
      background-size: 400% 400%;
      animation: gradientShift 20s ease infinite;
    }

    @keyframes gradientShift {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }
    
    /* Premium Title Screen */
    #title-screen {
      background: var(--dark-gradient);
      background-image: 
        radial-gradient(circle at 20% 20%, rgba(103, 126, 234, 0.2) 0%, transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(139, 92, 246, 0.15) 0%, transparent 40%),
        radial-gradient(circle at 50% 10%, rgba(251, 191, 36, 0.1) 0%, transparent 30%);
      animation: titleBackgroundPulse 8s ease-in-out infinite;
    }

    @keyframes titleBackgroundPulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.9; transform: scale(1.02); }
    }
    
    #title-screen h1 {
      font-family: var(--font-primary);
      font-size: clamp(2.5rem, 8vw, 5rem);
      font-weight: 900;
      margin-bottom: var(--space-lg);
      background: linear-gradient(135deg, var(--accent-gold), #f59e0b, var(--accent-blue));
      background-size: 200% 200%;
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: none;
      animation: titleGradientFlow 4s ease infinite, titleFloat 6s ease-in-out infinite;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    @keyframes titleGradientFlow {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    @keyframes titleFloat {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-10px); }
    }
    
    #title-screen .digivice-animation {
      width: min(250px, 40vw);
      height: min(250px, 40vw);
      background: var(--primary-gradient);
      border-radius: 50%;
      box-shadow: 
        0 0 50px rgba(103, 126, 234, 0.5),
        0 0 100px rgba(103, 126, 234, 0.3),
        inset 0 0 30px rgba(255, 255, 255, 0.1);
      margin: var(--space-xl) auto;
      position: relative;
      overflow: hidden;
      animation: digiviceRotate 10s linear infinite, digivicePulse 3s ease-in-out infinite;
    }
    
    .digivice-animation::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 70%;
      height: 70%;
      background: var(--dark-gradient);
      border-radius: 50%;
      box-shadow: 
        inset 0 0 20px rgba(0, 0, 0, 0.8),
        0 0 20px rgba(103, 126, 234, 0.3);
    }
    
    .digivice-animation::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40%;
      height: 40%;
      background: var(--secondary-gradient);
      border-radius: 50%;
      box-shadow: 
        0 0 30px rgba(139, 92, 246, 0.7),
        inset 0 0 15px rgba(255, 255, 255, 0.2);
      animation: screenPulse 2s ease-in-out infinite alternate;
    }
    
    @keyframes digiviceRotate {
      from { transform: rotateY(0deg) rotateZ(0deg); }
      to { transform: rotateY(360deg) rotateZ(5deg); }
    }

    @keyframes digivicePulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    @keyframes screenPulse {
      0% { 
        opacity: 0.8; 
        transform: translate(-50%, -50%) scale(0.95);
        box-shadow: 0 0 20px rgba(139, 92, 246, 0.5);
      }
      100% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1.1);
        box-shadow: 0 0 40px rgba(139, 92, 246, 0.8);
      }
    }
    
    #title-screen p {
      margin-top: var(--space-xl);
      font-size: clamp(1.2rem, 4vw, 1.8rem);
      font-family: var(--font-secondary);
      font-weight: 300;
      color: var(--text-secondary);
      cursor: pointer;
      animation: pressPrompt 2s ease-in-out infinite;
      text-shadow: 0 2px 10px rgba(255, 255, 255, 0.3);
      letter-spacing: 1px;
    }
    
    @keyframes pressPrompt {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.02); }
    }
    
    /* Premium Main Menu */
    #main-menu h2 {
      font-family: var(--font-primary);
      font-size: clamp(2rem, 6vw, 3rem);
      font-weight: 700;
      margin-bottom: var(--space-xl);
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: none;
      letter-spacing: 2px;
      text-transform: uppercase;
    }
    
    #main-menu .menu-options {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 420px;
      gap: var(--space-sm);
    }
    
    #main-menu .digimon-btn {
      width: 100%;
      padding: var(--space-md) var(--space-lg);
      font-size: 1rem;
      letter-spacing: 1.5px;
      border-radius: var(--radius-lg);
      position: relative;
      overflow: hidden;
    }

    #main-menu .digimon-btn::after {
      content: '';
      position: absolute;
      top: 0;
      right: 0;
      width: 0;
      height: 100%;
      background: rgba(255, 255, 255, 0.1);
      transition: width 0.3s ease;
      z-index: 1;
    }

    #main-menu .digimon-btn:hover::after {
      width: 100%;
    }

    /* Mobile-First Responsive Design */
    @media (max-width: 768px) {
      body {
        padding-top: max(var(--safe-top), 0px);
        padding-bottom: max(var(--safe-bottom), 0px);
      }

      .panel {
        padding: var(--space-md);
      }

      #title-screen h1 {
        font-size: clamp(2rem, 10vw, 3.5rem);
        margin-bottom: var(--space-md);
      }

      #title-screen .digivice-animation {
        width: min(200px, 50vw);
        height: min(200px, 50vw);
        margin: var(--space-lg) auto;
      }

      #title-screen p {
        font-size: clamp(1rem, 5vw, 1.4rem);
        margin-top: var(--space-lg);
      }

      .digimon-btn {
        min-height: 48px;
        font-size: 0.85rem;
        padding: var(--space-sm) var(--space-md);
      }

      #main-menu .digimon-btn {
        padding: var(--space-md);
        font-size: 0.9rem;
      }
    }

    /* iPhone X+ Safe Area Support */
    @supports (padding: max(0px)) {
      body {
        padding-left: max(var(--safe-left), var(--space-sm));
        padding-right: max(var(--safe-right), var(--space-sm));
      }
    }

    /* High DPI Displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
      .digimon-sprite,
      .party-sprite,
      .caught-digi-sprite,
      .scan-sprite {
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
      }
    }

    /* Landscape Mobile Optimization */
    @media (max-height: 500px) and (orientation: landscape) {
      .panel {
        padding: var(--space-sm);
        justify-content: flex-start;
        padding-top: var(--space-md);
      }

      #title-screen h1 {
        font-size: clamp(1.5rem, 8vw, 2.5rem);
        margin-bottom: var(--space-sm);
      }

      #title-screen .digivice-animation {
        width: min(120px, 25vw);
        height: min(120px, 25vw);
        margin: var(--space-sm) auto;
      }

      #title-screen p {
        margin-top: var(--space-sm);
        font-size: clamp(0.9rem, 4vw, 1.2rem);
      }
    }

    /* Tablet Optimization */
    @media (min-width: 768px) and (max-width: 1024px) {
      #game-container {
        max-width: 90vw;
        max-height: 90vh;
        margin: 5vh auto;
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-lg);
      }
    }

    /* Desktop Optimization */
    @media (min-width: 1025px) {
      #game-container {
        max-width: 1200px;
        max-height: 800px;
        margin: auto;
        border-radius: var(--radius-xl);
        box-shadow: var(--shadow-lg);
      }

      body {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
      }
    }

    /* Hover Effects (Desktop Only) */
    @media (hover: hover) {
      .digimon-btn:hover {
        transform: translateY(-3px) scale(1.02);
      }

      .glass:hover {
        background: rgba(255, 255, 255, 0.08);
        border-color: rgba(255, 255, 255, 0.2);
      }
    }

    /* Reduce Motion for Accessibility */
    @media (prefers-reduced-motion: reduce) {
      *,
      *::before,
      *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }

      .digivice-animation {
        animation: none !important;
      }

      #title-screen h1 {
        animation: none !important;
      }
    }

    /* Dark Mode Support */
    @media (prefers-color-scheme: dark) {
      :root {
        --glass-bg: rgba(255, 255, 255, 0.03);
        --glass-border: rgba(255, 255, 255, 0.08);
        --text-primary: rgba(255, 255, 255, 0.98);
        --text-secondary: rgba(255, 255, 255, 0.8);
      }
    }
    
    /* Premium Battle Screen Overrides */
    #battle-screen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: 100% !important;
      height: 100vh !important;
      height: calc(var(--vh, 1vh) * 100) !important;
      overflow: hidden !important;
      display: flex !important;
      flex-direction: column !important;
      
      /* Mobile-safe padding */
      padding: var(--space-sm) !important;
      padding-top: max(var(--safe-top), var(--space-sm)) !important;
      padding-bottom: max(var(--safe-bottom), var(--space-sm)) !important;
      
      /* Animated background */
      background: var(--dark-gradient) !important;
      background-image: 
        radial-gradient(circle at 20% 80%, rgba(103, 126, 234, 0.15) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(251, 191, 36, 0.05) 0%, transparent 50%) !important;
      background-size: 400% 400% !important;
      animation: gradientShift 15s ease infinite !important;
    }
    
    #battle-header {
      flex-shrink: 0 !important;
      margin-bottom: var(--space-xs) !important;
      padding: var(--space-sm) !important;
      min-height: auto !important;
    }
    
    .battle-top {
      display: grid !important;
      grid-template-columns: 1fr 1fr !important;
      gap: var(--space-xs) !important;
      flex-shrink: 0 !important;
      min-height: 140px !important;
      width: 100% !important;
      margin-bottom: 0 !important;
    }
    
    .digimon-battle-container {
      background: var(--glass-intense) !important;
      border-radius: var(--radius-lg) !important;
      padding: var(--space-md) !important;
      backdrop-filter: blur(40px) !important;
      -webkit-backdrop-filter: blur(40px) !important;
      border: 1px solid var(--glass-border) !important;
      box-shadow: var(--shadow-lg) !important;
      display: flex !important;
      flex-direction: column !important;
      position: relative !important;
      overflow: hidden !important;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1) !important;
      gap: var(--space-sm) !important;
      width: auto !important;
    }
    
    /* Premium Mobile-First Battle Layout Overrides */
    .battle-main {
      display: flex !important;
      flex-direction: column !important;
      flex: 1 !important;
      overflow: hidden !important;
      gap: var(--space-xs) !important;
      min-height: 0 !important;
    }
    
    .hp-section {
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
    }
    
    .digimon-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: var(--space-xs);
      margin-bottom: 0;
    }
    
    .digimon-name {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-family: var(--font-primary);
      margin-bottom: 0;
    }
    
    .digimon-name h3 {
      font-size: 1rem;
      font-weight: 700;
      color: var(--text-primary);
      margin: 0;
      letter-spacing: 0.5px;
    }
    
    .digimon-type {
      padding: var(--space-xs) var(--space-sm);
      border-radius: var(--radius-sm);
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: var(--font-primary);
    }
    
    .hp-bar {
      width: 100%;
      height: 12px;
      background: rgba(52, 74, 95, 0.5);
      border-radius: var(--radius-sm);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      position: relative;
      margin-bottom: 0;
    }
    
    .hp-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.1) 50%, transparent 100%);
      animation: shimmer 2s infinite;
    }
    
    @keyframes shimmer {
      0% { transform: translateX(-100%); }
      100% { transform: translateX(100%); }
    }
    
    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #7ed321, #c8e986);
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: var(--radius-sm);
      position: relative;
    }
    
    .hp-text {
      font-size: 0.8rem;
      text-align: right;
      color: var(--text-secondary);
      font-family: var(--font-primary);
      font-weight: 600;
    }
    
    .level-info {
      font-size: 0.8rem;
      color: var(--text-secondary);
      font-family: var(--font-primary);
      font-weight: 600;
    }
    
    .exp-bar {
      width: 100%;
      height: 4px;
      background: rgba(52, 74, 95, 0.5);
      border-radius: var(--radius-sm);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.1);
      margin-top: 0;
    }
    
    .exp-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--accent-blue), #00bcd4);
      transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
      border-radius: var(--radius-sm);
    }
    
    .digimon-sprite-container {
      width: 100%;
      height: 100px;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      background: rgba(255, 255, 255, 0.02);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.05);
    }
    
    .digimon-sprite {
      width: 80px;
      height: 80px;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
      border-radius: var(--radius-sm);
    }
    
    .player-sprite {
      transform: scale(1.1);
    }
    
    .enemy-sprite {
      transform: scale(1.1) scaleX(-1);
    }
    
    .battle-log-container {
      flex: 1 !important;
      min-height: 80px !important;
      max-height: 120px !important;
      overflow: hidden !important;
      margin: 0 !important;
    }
    
    .battle-log {
      width: 100% !important;
      height: 100% !important;
      background: var(--glass-intense) !important;
      border-radius: var(--radius-lg) !important;
      padding: var(--space-sm) !important;
      overflow-y: auto !important;
      font-size: 0.8rem !important;
      backdrop-filter: blur(40px) !important;
      -webkit-backdrop-filter: blur(40px) !important;
      border: 1px solid var(--glass-border) !important;
      box-shadow: var(--shadow-md) !important;
      color: var(--text-primary) !important;
      font-family: var(--font-secondary) !important;
      line-height: 1.3 !important;
    }
    
    .battle-actions {
      display: grid !important;
      grid-template-columns: repeat(3, 1fr) !important;
      gap: var(--space-xs) !important;
      flex-shrink: 0 !important;
      padding-top: 0 !important;
      margin-top: var(--space-xs) !important;
    }
    
    .battle-actions .digimon-btn {
      margin: 0;
      padding: var(--space-sm);
      font-size: 0.8rem;
      min-height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      white-space: nowrap;
      flex: 1;
      max-width: none;
    }
    
    /* Mobile Responsive Adjustments */
    @media (max-width: 480px) {
      .battle-top {
        grid-template-columns: 1fr !important;
        gap: var(--space-xs) !important;
        min-height: 120px !important;
      }
      
      .digimon-battle-container {
        padding: var(--space-sm) !important;
        gap: var(--space-xs) !important;
      }
      
      .digimon-sprite-container {
        height: 60px !important;
      }
      
      .digimon-sprite {
        width: 50px !important;
        height: 50px !important;
      }
      
      .battle-log-container {
        min-height: 60px !important;
        max-height: 80px !important;
      }
      
      .battle-actions {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: var(--space-xs) !important;
      }
      
      .battle-actions .digimon-btn {
        font-size: 0.7rem !important;
        padding: var(--space-xs) !important;
        min-height: 40px !important;
      }
    }
    
    /* Landscape Mobile Optimization */
    @media (max-height: 600px) and (orientation: landscape) {
      #battle-screen {
        padding: var(--space-xs) !important;
      }
      
      .battle-main {
        gap: 4px !important;
      }
      
      .battle-top {
        min-height: 100px !important;
      }
      
      .digimon-battle-container {
        padding: var(--space-xs) !important;
        gap: 4px !important;
      }
      
      .digimon-sprite-container {
        height: 50px !important;
      }
      
      .digimon-sprite {
        width: 40px !important;
        height: 40px !important;
      }
      
      .battle-log-container {
        min-height: 50px !important;
        max-height: 60px !important;
      }
      
      .battle-log {
        padding: var(--space-xs) !important;
        font-size: 0.7rem !important;
        line-height: 1.2 !important;
      }
      
      .battle-actions .digimon-btn {
        padding: 4px !important;
        font-size: 0.65rem !important;
        min-height: 36px !important;
      }
      
      #battle-header {
        padding: var(--space-xs) !important;
        margin-bottom: 4px !important;
      }
    }
    
    /* Extra small screens */
    @media (max-height: 500px) {
      .battle-top {
        min-height: 80px !important;
      }
      
      .digimon-sprite-container {
        height: 40px !important;
      }
      
      .digimon-sprite {
        width: 35px !important;
        height: 35px !important;
      }
      
      .battle-log-container {
        min-height: 40px !important;
        max-height: 50px !important;
      }
      
      .battle-actions .digimon-btn {
        font-size: 0.6rem !important;
        min-height: 32px !important;
        padding: 2px !important;
      }
    }
    
    /* Premium Character Select */
    #character-select h2 {
      font-family: var(--font-primary);
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      font-weight: 700;
      margin-bottom: var(--space-lg);
      background: var(--primary-gradient);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-transform: uppercase;
      letter-spacing: 1.5px;
    }
    
    #starter-digimon-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: var(--space-md);
      width: 100%;
      max-width: 800px;
      margin-bottom: var(--space-xl);
      padding: 0 var(--space-sm);
    }
    
    .digimon-starter-card {
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-lg);
      padding: var(--space-md);
      text-align: center;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      box-shadow: var(--shadow-md);
      overflow: hidden;
      min-height: 220px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .digimon-starter-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: var(--primary-gradient);
      opacity: 0;
      transition: opacity 0.3s ease;
      z-index: -1;
    }
    
    .digimon-starter-card:hover {
      transform: translateY(-8px) scale(1.02);
      box-shadow: var(--shadow-lg), var(--shadow-glow);
      border-color: rgba(103, 126, 234, 0.5);
    }

    .digimon-starter-card:hover::before {
      opacity: 0.1;
    }
    
    .digimon-starter-card.selected {
      border: 2px solid var(--accent-gold);
      box-shadow: 0 0 30px rgba(251, 191, 36, 0.4), var(--shadow-lg);
      background: rgba(251, 191, 36, 0.05);
    }

    .digimon-starter-card.selected::before {
      background: linear-gradient(135deg, var(--accent-gold), #f59e0b);
      opacity: 0.15;
    }
    
    .digimon-starter-card.locked {
      opacity: 0.4;
      cursor: not-allowed;
      filter: grayscale(0.8);
    }
    
    .digimon-starter-card.locked::after {
      content: '🔒';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.5em;
      color: var(--accent-gold);
      text-shadow: 0 0 10px rgba(251, 191, 36, 0.5);
      z-index: 10;
    }
    
    .digimon-starter-card img {
      width: 100px;
      height: 100px;
      display: block;
      margin: 0 auto var(--space-sm);
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.05);
      padding: var(--space-xs);
      transition: all 0.4s ease;
      border: 2px solid transparent;
    }
    
    .digimon-starter-card:hover img {
      transform: scale(1.1) rotateY(10deg);
      border-color: rgba(103, 126, 234, 0.3);
      box-shadow: 0 0 20px rgba(103, 126, 234, 0.3);
    }

    .digimon-starter-card.selected img {
      border-color: var(--accent-gold);
      box-shadow: 0 0 20px rgba(251, 191, 36, 0.4);
    }
    
    .digimon-starter-card p {
      font-family: var(--font-primary);
      font-weight: 600;
      font-size: 1.1rem;
      color: var(--text-primary);
      margin: 0;
      letter-spacing: 0.5px;
    }
    
    .digimon-starter-card .type {
      font-family: var(--font-secondary);
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-top: var(--space-xs);
      padding: var(--space-xs) var(--space-sm);
      background: rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-sm);
      display: inline-block;
    }
    
    #digivice-selection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 20px;
      max-width: 700px;
    }
    
    .digivice-option {
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 8px;
      border: 1px solid #4a6fa5;
      margin: 10px;
      padding: 15px;
      width: 150px;
      height: 100px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .digivice-option:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      border-color: #ff8c00;
    }
    
    .digivice-option.selected {
      border: 2px solid #ff8c00;
      box-shadow: 0 0 15px rgba(255, 140, 0, 0.5);
    }
    
    .digivice-option.locked {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .digivice-option p {
      margin-top: 8px;
      font-size: 0.8em;
      color: #4a6fa5;
    }
    
    /* Battle Screen */
    #battle-screen {
      display: none;
      flex-direction: column;
      justify-content: flex-start;
      padding: 15px;
      background: url('https://images.unsplash.com/photo-1557683316-973673baf926?q=80&w=2429&auto=format&fit=crop') no-repeat center center;
      background-size: cover;
      position: relative;
      height: 100%;
    }
    
    #battle-screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 15, 30, 0.7);
      z-index: 0;
    }
    
    #battle-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      margin-bottom: 10px;
      padding: 10px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      z-index: 1;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .round-info {
      font-size: 1.2em;
      font-weight: bold;
      color: #ff8c00;
    }
    
    .battle-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      width: 100%;
      margin-bottom: 15px;
      z-index: 1;
      position: relative;
    }
    
    .digimon-battle-container {
      width: 45%;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .digimon-info {
      margin-bottom: 10px;
    }
    
    .digimon-name {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }
    
    .digimon-name h3 {
      font-size: 1.2em;
      color: #fff;
    }
    
    .digimon-type {
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .type-data {
      background-color: #4a90e2;
      color: #fff;
    }
    
    .type-vaccine {
      background-color: #7ed321;
      color: #fff;
    }
    
    .type-virus {
      background-color: #d0021b;
      color: #fff;
    }
    
    .hp-bar {
      width: 100%;
      height: 15px;
      background-color: #344a5f;
      border-radius: 10px;
      margin-bottom: 5px;
      overflow: hidden;
    }
    
    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #7ed321, #c8e986);
      width: 100%;
      transition: width 0.5s ease;
    }
    
    .hp-text {
      font-size: 0.9em;
      text-align: right;
      color: #ddd;
    }
    
    .exp-bar {
      width: 100%;
      height: 5px;
      background-color: #344a5f;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    
    .exp-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #00bcd4);
      width: 30%;
      transition: width 0.5s ease;
    }
    
    .digimon-sprite-container {
      width: 100%;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    
    .digimon-sprite {
      width: 120px;
      height: 120px;
      background-size: cover;
      background-position: center;
      transition: all 0.3s ease;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
    }
    
    .player-sprite {
      transform: scale(1.2);
    }
    
    .enemy-sprite {
      transform: scale(1.2) scaleX(-1);
    }
    
    .battle-log-container {
      width: 100%;
      margin: 15px 0;
      z-index: 1;
    }
    
    .battle-log {
      width: 100%;
      height: 150px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      font-size: 0.9em;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      color: #eee;
    }
    
    .battle-log p {
      margin-bottom: 5px;
      line-height: 1.4;
    }
    
    .log-attack {
      color: #ff8c00;
    }
    
    .log-heal {
      color: #7ed321;
    }
    
    .log-damage {
      color: #d0021b;
    }
    
    .battle-actions {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      z-index: 1;
    }
    
    .battle-actions .digimon-btn {
      flex: 1 0 calc(33.333% - 10px);
      max-width: 150px;
      margin: 5px;
      text-align: center;
    }
    
    /* Overlays */
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(10, 15, 30, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      color: #fff;
      z-index: 50;
      padding: 30px 20px;
      overflow-y: auto;
    }
    
    .overlay h2 {
      margin: 10px 0 20px;
      color: #ff8c00;
      text-shadow: 0 0 10px rgba(255, 140, 0, 0.3);
    }
    
    .overlay .close-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: linear-gradient(135deg, #d0021b, #c2185b);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 18px;
      padding: 0;
    }
    
    .overlay-content {
      width: 90%;
      max-width: 700px;
      margin: 20px auto;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }
    
    /* Move selection */
    #move-selection-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    
    .move-btn {
      display: flex;
      flex-direction: column;
      width: calc(50% - 20px);
      margin: 10px;
      padding: 15px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      transition: all 0.3s ease;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .move-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .move-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    .move-name {
      font-weight: bold;
      color: #fff;
    }
    
    .move-pp {
      color: #4a90e2;
    }
    
    .move-type {
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .move-description {
      font-size: 0.9em;
      color: #bbb;
    }
    
    /* DE Card Overlay */
    #de-card-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    
    .de-card {
      width: 160px;
      height: 220px;
      margin: 15px;
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      padding: 15px;
      border: 2px solid #4a6fa5;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .de-card:hover {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
      border-color: #ff8c00;
    }
    
    .de-card::after {
      content: '';
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
      pointer-events: none;
    }
    
    .de-card-header {
      text-align: center;
      margin-bottom: 15px;
      position: relative;
    }
    
    .de-card-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 5px;
    }
    
    .de-card-power {
      position: absolute;
      top: 0;
      right: 0;
      width: 30px;
      height: 30px;
      background: #ff8c00;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: #fff;
      font-size: 0.8em;
    }
    
    .de-card-rarity {
      font-size: 0.8em;
      color: #4a90e2;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .de-card-type {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
      margin-top: 5px;
    }
    
    .de-card-description {
      flex: 1;
      display: flex;
      align-items: center;
      text-align: center;
      font-size: 0.9em;
      color: #ddd;
      padding: 5px;
      border-top: 1px solid #4a6fa5;
      margin-top: 10px;
    }
    
    /* Party Overlay */
    #party-info {
      width: 100%;
    }
    
    .party-digimon-card {
      display: flex;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      margin-bottom: 15px;
      padding: 15px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .party-digimon-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .party-sprite {
      width: 80px;
      height: 80px;
      background-size: cover;
      margin-right: 15px;
      border-radius: 8px;
      background-color: rgba(255,255,255,0.1);
    }
    
    .party-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    
    .party-digimon-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }
    
    .party-digimon-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
    }
    
    .party-digimon-level {
      background: #ff8c00;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
      color: #fff;
    }
    
    .party-hp {
      margin-bottom: 10px;
    }
    
    .party-hp-bar {
      width: 100%;
      height: 10px;
      background-color: #344a5f;
      border-radius: 10px;
      margin-bottom: 5px;
      overflow: hidden;
    }
    
    .party-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #7ed321, #c8e986);
      width: 65%;
      transition: width 0.5s ease;
    }
    
    .party-hp-text {
      font-size: 0.9em;
      text-align: right;
      color: #ddd;
    }
    
    .party-moves {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    
    .party-move {
      font-size: 0.8em;
      background: rgba(28, 37, 65, 0.8);
      padding: 3px 8px;
      margin-right: 5px;
      margin-bottom: 5px;
      border-radius: 4px;
      color: #ddd;
    }
    
    .party-actions {
      display: flex;
      justify-content: flex-end;
    }
    
    .party-btn {
      padding: 5px 10px;
      font-size: 0.9em;
    }
    
    /* Item Overlay */
    #item-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .item-card {
      width: 120px;
      margin: 10px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .item-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .item-icon {
      font-size: 2em;
      margin-bottom: 10px;
      color: #ff8c00;
    }
    
    .item-name {
      font-weight: bold;
      margin-bottom: 5px;
      color: #fff;
    }
    
    .item-quantity {
      font-size: 0.9em;
      color: #4a90e2;
      margin-bottom: 10px;
    }
    
    /* DigiScan Overlay */
    .scan-info-container {
      width: 100%;
      max-width: 500px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }
    
    .scan-header {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .scan-sprite {
      width: 100px;
      height: 100px;
      background-size: cover;
      margin-right: 20px;
      border-radius: 8px;
      background-color: rgba(255,255,255,0.1);
    }
    
    .scan-basics {
      flex: 1;
    }
    
    .scan-name {
      font-size: 1.3em;
      font-weight: bold;
      color: #fff;
      margin-bottom: 5px;
    }
    
    .scan-details {
      margin-bottom: 20px;
    }
    
    .scan-details p {
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
    }
    
    .scan-label {
      font-weight: bold;
      color: #4a90e2;
    }
    
    .scan-stats {
      display: flex;
      flex-wrap: wrap;
    }
    
    .scan-stat {
      flex: 1 0 50%;
      margin-bottom: 10px;
    }
    
    .scan-moves {
      margin-top: 20px;
    }
    
    .scan-moves-title {
      font-weight: bold;
      color: #4a90e2;
      margin-bottom: 10px;
      border-bottom: 1px solid #4a6fa5;
      padding-bottom: 5px;
    }
    
    .scan-move {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 5px;
      background: rgba(28, 37, 65, 0.5);
      border-radius: 4px;
    }
    
    /* Rewards & Shop */
    #reward-selection, #shop-screen {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(10, 15, 30, 0.9);
    }
    
    #reward-selection h2, #shop-screen h2 {
      color: #ff8c00;
      margin-bottom: 20px;
    }
    
    #reward-grid, #shop-items {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 80%;
      margin: 0 auto 20px;
    }
    
    .reward-card, .shop-item-card {
      width: 160px;
      height: 200px;
      margin: 15px;
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      text-align: center;
      border: 2px solid #4a6fa5;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .reward-card:hover, .shop-item-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
      border-color: #ff8c00;
    }
    
    .reward-card.selected {
      border-color: #ff8c00;
      box-shadow: 0 0 20px rgba(255, 140, 0, 0.5);
    }
    
    .reward-icon, .shop-icon {
      font-size: 2.5em;
      margin-bottom: 15px;
      color: #ff8c00;
    }
    
    .reward-name, .shop-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 10px;
    }
    
    .reward-description, .shop-description {
      font-size: 0.9em;
      color: #bbb;
      flex: 1;
      display: flex;
      align-items: center;
    }
    
    .shop-price {
      margin-top: 10px;
      background: #ff8c00;
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
      color: #fff;
    }
    
    /* End Run Panel */
    #end-run-panel {
      display: none;
      flex-direction: column;
      align-items: center;
      background: rgba(10, 15, 30, 0.9);
    }
    
    #end-run-panel h2 {
      color: #ff8c00;
      margin-bottom: 30px;
      font-size: 2em;
    }
    
    #end-run-summary {
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 20px;
      width: 80%;
      max-width: 600px;
      text-align: left;
      margin-bottom: 30px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }
    
    #end-run-summary h3 {
      color: #4a90e2;
      margin-bottom: 15px;
      border-bottom: 1px solid #4a6fa5;
      padding-bottom: 10px;
    }
    
    .summary-stats {
      margin-bottom: 20px;
    }
    
    .summary-stat {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    .summary-label {
      font-weight: bold;
      color: #ddd;
    }
    
    .summary-value {
      color: #ff8c00;
      font-weight: bold;
    }
    
    .summary-rewards {
      margin-top: 20px;
    }
    
    .summary-reward {
      background: rgba(28, 37, 65, 0.5);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
    }

    /* ATTACK ANIMATIONS SYSTEM */

    /* Common Animation Container */
    .attack-animation-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      perspective: 1000px;
    }

    /* Animation Overlay */
    .attack-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.3), rgba(10, 20, 40, 0.5));
      z-index: 1001;
      opacity: 0;
      animation: fadeInOut 1.8s forwards;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; }
      20% { opacity: 0.7; }
      80% { opacity: 0.7; }
      100% { opacity: 0; }
    }

    /* Digital field effect for both animations */
    .attack-digital-field {
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(74, 111, 165, 0.05) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(74, 111, 165, 0.05) 1px, transparent 1px);
      background-size: 20px 20px;
      z-index: 1001;
      opacity: 0;
      animation: digitalFieldPulse 1.8s forwards;
    }

    @keyframes digitalFieldPulse {
      0% { opacity: 0; }
      30% { opacity: 0.5; }
      80% { opacity: 0.5; }
      100% { opacity: 0; }
    }

    /* Digimon sprite representations */
    .attacker-sprite, .target-sprite {
      position: absolute;
      width: 120px;
      height: 120px;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 1002;
    }

    .attacker-sprite {
      left: 20%;
      top: 50%;
      transform: translateY(-50%);
    }

    .target-sprite {
      right: 20%;
      top: 50%;
      transform: translateY(-50%) scaleX(-1);
    }

    /* Enemy shake animation */
    @keyframes targetShake {
      0% { transform: translateY(-50%) scaleX(-1) translateX(0); }
      20% { transform: translateY(-50%) scaleX(-1) translateX(-10px); }
      40% { transform: translateY(-50%) scaleX(-1) translateX(8px); }
      60% { transform: translateY(-50%) scaleX(-1) translateX(-6px); }
      80% { transform: translateY(-50%) scaleX(-1) translateX(4px); }
      100% { transform: translateY(-50%) scaleX(-1) translateX(0); }
    }
    
    /* Flipped target shake animation */
    @keyframes targetShakeFlipped {
      0% { transform: translateY(-50%) translateX(0); }
      20% { transform: translateY(-50%) translateX(10px); }
      40% { transform: translateY(-50%) translateX(-8px); }
      60% { transform: translateY(-50%) translateX(6px); }
      80% { transform: translateY(-50%) translateX(-4px); }
      100% { transform: translateY(-50%) translateX(0); }
    }

    /* Flash effect */
    .flash-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0);
      z-index: 1010;
    }

    @keyframes quickFlash {
      0% { background: rgba(255, 255, 255, 0); }
      50% { background: rgba(255, 255, 255, 0.6); }
      100% { background: rgba(255, 255, 255, 0); }
    }

    @keyframes strongFlash {
      0% { background: rgba(255, 255, 255, 0); }
      30% { background: rgba(255, 255, 255, 0.9); }
      100% { background: rgba(255, 255, 255, 0); }
    }

    /* ===== PHYSICAL ATTACK ANIMATIONS ===== */

    /* Attacker movement for physical attack */
    @keyframes attackerLunge {
      0% { transform: translateY(-50%) translateX(0) rotate(0deg); }
      20% { transform: translateY(-50%) translateX(-20px) rotate(-5deg); }
      30% { transform: translateY(-50%) translateX(-10px) rotate(0deg); }
      60% { transform: translateY(-50%) translateX(100px) rotate(5deg); }
      80% { transform: translateY(-50%) translateX(100px) rotate(0deg); }
      100% { transform: translateY(-50%) translateX(0) rotate(0deg); }
    }
    
    /* Flipped attacker movement */
    @keyframes attackerLungeFlipped {
      0% { transform: translateY(-50%) scaleX(-1) translateX(0) rotate(0deg); }
      20% { transform: translateY(-50%) scaleX(-1) translateX(20px) rotate(5deg); }
      30% { transform: translateY(-50%) scaleX(-1) translateX(10px) rotate(0deg); }
      60% { transform: translateY(-50%) scaleX(-1) translateX(-100px) rotate(-5deg); }
      80% { transform: translateY(-50%) scaleX(-1) translateX(-100px) rotate(0deg); }
      100% { transform: translateY(-50%) scaleX(-1) translateX(0) rotate(0deg); }
    }

    /* Slash effect lines */
    .slash-line {
      position: absolute;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%);
      height: 3px;
      width: 0;
      transform-origin: left center;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 140, 0, 0.6);
      border-radius: 2px;
      z-index: 1003;
    }

    @keyframes slashGrow {
      0% { width: 0; opacity: 0; }
      30% { width: 100px; opacity: 1; }
      100% { width: 150px; opacity: 0; }
    }
    
    /* Flipped slash growth animation */
    @keyframes slashGrowFlipped {
      0% { width: 0; opacity: 0; transform-origin: right center; }
      30% { width: 100px; opacity: 1; transform-origin: right center; }
      100% { width: 150px; opacity: 0; transform-origin: right center; }
    }

    /* Impact burst effect */
    .impact-burst {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,140,0,0.8) 30%, rgba(255,140,0,0) 70%);
      border-radius: 50%;
      top: 50%;
      right: 20%;
      transform: translate(0, -50%) scale(0);
      opacity: 0;
      box-shadow: 0 0 20px rgba(255, 140, 0, 0.6);
      z-index: 1004;
    }

    @keyframes impactBurst {
      0% { transform: translate(0, -50%) scale(0); opacity: 0; }
      30% { transform: translate(0, -50%) scale(2); opacity: 1; }
      100% { transform: translate(0, -50%) scale(4); opacity: 0; }
    }
    
    /* Flipped impact burst animation */
    @keyframes impactBurstFlipped {
      0% { transform: translate(0, -50%) scale(0); opacity: 0; }
      30% { transform: translate(0, -50%) scale(2); opacity: 1; }
      100% { transform: translate(0, -50%) scale(4); opacity: 0; }
    }

    /* Digital particles effect */
    .phy-particle {
      position: absolute;
      width: 5px;
      height: 5px;
      background: #ff8c00;
      border-radius: 50%;
      opacity: 0;
      box-shadow: 0 0 10px rgba(255, 140, 0, 0.8);
      z-index: 1005;
    }

    /* ===== SPECIAL ATTACK ANIMATIONS ===== */

    /* Attacker aura effect */
    .attacker-aura {
      position: absolute;
      width: 160px;
      height: 160px;
      left: 20%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: radial-gradient(circle, rgba(0,170,255,0.7) 0%, rgba(0,170,255,0.3) 50%, rgba(0,170,255,0) 70%);
      border-radius: 50%;
      box-shadow: 0 0 30px rgba(0, 170, 255, 0.5);
      z-index: 1003;
      opacity: 0;
    }

    @keyframes auraGrow {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.8; }
      100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.6; }
    }
    
    /* Flipped aura grow animation */
    @keyframes auraGrowFlipped {
      0% { transform: translate(50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(50%, -50%) scale(1.5); opacity: 0.8; }
      100% { transform: translate(50%, -50%) scale(1.2); opacity: 0.6; }
    }

    /* Energy charge particles */
    .sp-energy-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #00aaff;
      border-radius: 50%;
      opacity: 0;
      box-shadow: 0 0 10px rgba(0, 170, 255, 0.8);
      z-index: 1004;
    }

    @keyframes particleConverge {
      0% { transform: translate(0, 0) scale(1); opacity: 0; }
      50% { transform: translate(-30px, 0) scale(1.5); opacity: 0.8; }
      100% { transform: translate(-50px, 0) scale(0.5); opacity: 0; }
    }
    
    /* Flipped particle converge animation */
    @keyframes particleConvergeFlipped {
      0% { transform: translate(0, 0) scale(1); opacity: 0; }
      50% { transform: translate(30px, 0) scale(1.5); opacity: 0.8; }
      100% { transform: translate(50px, 0) scale(0.5); opacity: 0; }
    }

    /* Energy beam */
    .energy-beam {
      position: absolute;
      height: 30px;
      background: linear-gradient(90deg, rgba(0,170,255,0.9), rgba(100,200,255,0.9), rgba(255,255,255,0.9), rgba(100,200,255,0.9), rgba(0,170,255,0.9));
      top: 50%;
      left: 25%;
      transform: translateY(-50%);
      transform-origin: left center;
      width: 0;
      box-shadow: 0 0 20px rgba(0, 170, 255, 0.8), 0 0 40px rgba(0, 170, 255, 0.4);
      border-radius: 15px;
      opacity: 0;
      z-index: 1005;
    }

    .beam-pattern {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(90deg, transparent 0%, transparent 30%, rgba(255,255,255,0.5) 50%, transparent 70%, transparent 100%),
        repeating-linear-gradient(90deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px);
      background-size: 100% 100%, 20px 20px;
      opacity: 0.7;
      animation: patternMove 1s linear infinite;
    }

    @keyframes patternMove {
      0% { background-position: 0 0, 0 0; }
      100% { background-position: 100px 0, 20px 0; }
    }

    @keyframes beamExtend {
      0% { width: 0; opacity: 0.3; }
      50% { width: 50%; opacity: 1; }
      100% { width: 45%; opacity: 0.9; }
    }
    
    /* Flipped beam extend animation */
    @keyframes beamExtendFlipped {
      0% { width: 0; opacity: 0.3; }
      50% { width: 50%; opacity: 1; }
      100% { width: 45%; opacity: 0.9; }
    }

    /* Base styles (continued) */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      background: #111;
      color: #eee;
      overflow: hidden;
    }
    
    body {
      display: flex;
      justify-content: center;
      align-items: center;
    }
    
    #game-container {
      position: relative;
      width: 100%;
      max-width: 900px;
      height: 100%;
      max-height: 650px;
      margin: 0 auto;
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }
    
    /* Scrollable elements */
    .scrollable {
      overflow-y: auto;
      scrollbar-width: thin;
      scrollbar-color: #4a6fa5 #16213e;
    }
    
    .scrollable::-webkit-scrollbar {
      width: 8px;
    }
    
    .scrollable::-webkit-scrollbar-track {
      background: #16213e;
    }
    
    .scrollable::-webkit-scrollbar-thumb {
      background-color: #4a6fa5;
      border-radius: 10px;
    }
    
    /* Buttons */
    .digimon-btn {
      background: linear-gradient(135deg, #4a6fa5, #344fa1);
      border: none;
      border-radius: 4px;
      color: #fff;
      padding: 8px 16px;
      margin: 5px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 14px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .digimon-btn:hover {
      background: linear-gradient(135deg, #5a7fb5, #4a6fa5);
      transform: translateY(-2px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
    }
    
    .digimon-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    /* Panels */
    .panel {
      position: absolute;
      top: 0; left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(10, 15, 30, 0.85);
      backdrop-filter: blur(5px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      text-align: center;
      z-index: 10;
      padding: 20px;
      overflow-y: auto;
    }
    
    /* Title Screen */
    #title-screen {
      background: radial-gradient(circle, #1a1a2e, #0f0f1a);
      background-size: 200% 200%;
      animation: pulseBackground 5s infinite alternate;
    }
    
    @keyframes pulseBackground {
      0% { background-position: 0% 0%; }
      100% { background-position: 100% 100%; }
    }
    
    #title-screen h1 {
      font-size: 3em;
      margin-bottom: 20px;
      color: #ffb347;
      text-shadow: 0 0 15px #ff8c00, 0 0 25px #ff8c00;
      animation: titleGlow 3s infinite alternate;
      letter-spacing: 2px;
    }
    
    @keyframes titleGlow {
      0% { text-shadow: 0 0 15px #ff8c00, 0 0 25px #ff8c00; }
      100% { text-shadow: 0 0 25px #ff8c00, 0 0 40px #ff8c00; }
    }
    
    #title-screen .digivice-animation {
      width: 180px;
      height: 180px;
      background-color: #ff8c00;
      border-radius: 50%;
      box-shadow: 0 0 30px #ff8c00, inset 0 0 20px rgba(255, 255, 255, 0.5);
      margin: 20px auto;
      position: relative;
      overflow: hidden;
      animation: rotateDigivice 8s linear infinite;
    }
    
    .digivice-animation::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 70%;
      height: 70%;
      background-color: #16213e;
      border-radius: 50%;
      box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
    }
    
    .digivice-animation::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40%;
      height: 40%;
      background-color: #4a6fa5;
      border-radius: 50%;
      box-shadow: 0 0 15px #4a6fa5;
      animation: pulseScreen 2s infinite alternate;
    }
    
    @keyframes rotateDigivice {
      0% { transform: rotateY(0deg); }
      100% { transform: rotateY(360deg); }
    }
    
    @keyframes pulseScreen {
      0% { opacity: 0.7; transform: translate(-50%, -50%) scale(0.95); }
      100% { opacity: 1; transform: translate(-50%, -50%) scale(1.05); }
    }
    
    #title-screen p {
      margin-top: 30px;
      font-size: 1.5em;
      color: #fff;
      cursor: pointer;
      animation: blinkPress 1.5s infinite alternate;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }
    
    @keyframes blinkPress {
      0% { opacity: 1; }
      100% { opacity: 0.3; }
    }
    
    /* Main Menu */
    #main-menu h2 {
      font-size: 2.2em;
      margin-bottom: 30px;
      color: #ffb347;
      text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
    }
    
    #main-menu .menu-options {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 90%;
      max-width: 400px;
    }
    
    #main-menu .digimon-btn {
      width: 100%;
      margin: 8px 0;
      padding: 12px;
      font-size: 1.1em;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    /* Character Select */
    #character-select h2 {
      font-size: 1.8em;
      margin-bottom: 15px;
      color: #ffb347;
      text-shadow: 0 0 10px rgba(255, 140, 0, 0.3);
    }
    
    #starter-digimon-grid {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 700px;
      margin-bottom: 20px;
    }
    
    .digimon-starter-card {
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 8px;
      border: 1px solid #4a6fa5;
      width: 140px;
      height: 180px;
      margin: 10px;
      padding: 15px 10px;
      text-align: center;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .digimon-starter-card:hover {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      border-color: #ff8c00;
    }
    
    .digimon-starter-card.selected {
      border: 2px solid #ff8c00;
      box-shadow: 0 0 15px rgba(255, 140, 0, 0.5);
    }
    
    .digimon-starter-card.locked {
      opacity: 0.5;
      cursor: not-allowed;
    }
    
    .digimon-starter-card.locked::after {
      content: '🔒';
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: #ff8c00;
    }
    
    .digimon-starter-card img {
      width: 80px;
      height: 80px;
      display: block;
      margin: 5px auto;
      border-radius: 50%;
      background-color: rgba(255, 255, 255, 0.1);
      padding: 5px;
      transition: all 0.3s ease;
    }
    
    .digimon-starter-card:hover img {
      transform: scale(1.1);
    }
    
    .digimon-starter-card p {
      margin-top: 10px;
      font-weight: bold;
      color: #fff;
    }
    
    .digimon-starter-card .type {
      font-size: 0.8em;
      color: #4a6fa5;
      margin-top: 5px;
    }
    
    #digivice-selection {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-top: 20px;
      max-width: 700px;
    }
    
    .digivice-option {
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 8px;
      border: 1px solid #4a6fa5;
      margin: 10px;
      padding: 15px;
      width: 150px;
      height: 100px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-align: center;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .digivice-option:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      border-color: #ff8c00;
    }
    
    .digivice-option.selected {
      border: 2px solid #ff8c00;
      box-shadow: 0 0 15px rgba(255, 140, 0, 0.5);
    }
    
    .digivice-option.locked {
      opacity: 0.4;
      cursor: not-allowed;
    }
    
    .digivice-option p {
      margin-top: 8px;
      font-size: 0.8em;
      color: #4a6fa5;
    }
    
    /* Battle Screen */
    #battle-screen {
      display: none;
      flex-direction: column;
      justify-content: flex-start;
      padding: 15px;
      background: url('https://images.unsplash.com/photo-1557683316-973673baf926?q=80&w=2429&auto=format&fit=crop') no-repeat center center;
      background-size: cover;
      position: relative;
      height: 100%;
    }
    
    #battle-screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 15, 30, 0.7);
      z-index: 0;
    }
    
    #battle-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      margin-bottom: 10px;
      padding: 10px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      z-index: 1;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .round-info {
      font-size: 1.2em;
      font-weight: bold;
      color: #ff8c00;
    }
    
    .battle-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      width: 100%;
      margin-bottom: 15px;
      z-index: 1;
      position: relative;
    }
    
    .digimon-battle-container {
      width: 45%;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .digimon-info {
      margin-bottom: 10px;
    }
    
    .digimon-name {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 5px;
    }
    
    .digimon-name h3 {
      font-size: 1.2em;
      color: #fff;
    }
    
    .digimon-type {
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .type-data {
      background-color: #4a90e2;
      color: #fff;
    }
    
    .type-vaccine {
      background-color: #7ed321;
      color: #fff;
    }
    
    .type-virus {
      background-color: #d0021b;
      color: #fff;
    }
    
    .hp-bar {
      width: 100%;
      height: 15px;
      background-color: #344a5f;
      border-radius: 10px;
      margin-bottom: 5px;
      overflow: hidden;
    }
    
    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #7ed321, #c8e986);
      width: 100%;
      transition: width 0.5s ease;
    }
    
    .hp-text {
      font-size: 0.9em;
      text-align: right;
      color: #ddd;
    }
    
    .exp-bar {
      width: 100%;
      height: 5px;
      background-color: #344a5f;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }
    
    .exp-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #00bcd4);
      width: 30%;
      transition: width 0.5s ease;
    }
    
    .digimon-sprite-container {
      width: 100%;
      height: 150px;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
    }
    
    .digimon-sprite {
      width: 120px;
      height: 120px;
      background-size: cover;
      background-position: center;
      transition: all 0.3s ease;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
    }
    
    .player-sprite {
      transform: scale(1.2);
    }
    
    .enemy-sprite {
      transform: scale(1.2) scaleX(-1);
    }
    
    .battle-log-container {
      width: 100%;
      margin: 15px 0;
      z-index: 1;
    }
    
    .battle-log {
      width: 100%;
      height: 150px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 10px;
      overflow-y: auto;
      font-size: 0.9em;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      color: #eee;
    }
    
    .battle-log p {
      margin-bottom: 5px;
      line-height: 1.4;
    }
    
    .log-attack {
      color: #ff8c00;
    }
    
    .log-heal {
      color: #7ed321;
    }
    
    .log-damage {
      color: #d0021b;
    }
    
    .battle-actions {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
      z-index: 1;
    }
    
    .battle-actions .digimon-btn {
      flex: 1 0 calc(33.333% - 10px);
      max-width: 150px;
      margin: 5px;
      text-align: center;
    }
    
    /* Overlays */
    .overlay {
      position: absolute;
      top: 0; left: 0;
      width: 100%; 
      height: 100%;
      background: rgba(10, 15, 30, 0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      color: #fff;
      z-index: 50;
      padding: 30px 20px;
      overflow-y: auto;
    }
    
    .overlay h2 {
      margin: 10px 0 20px;
      color: #ff8c00;
      text-shadow: 0 0 10px rgba(255, 140, 0, 0.3);
    }
    
    .overlay .close-btn {
      position: absolute;
      top: 15px;
      right: 15px;
      background: linear-gradient(135deg, #d0021b, #c2185b);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 18px;
      padding: 0;
    }
    
    .overlay-content {
      width: 90%;
      max-width: 700px;
      margin: 20px auto;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }
    
    /* Move selection */
    #move-selection-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    
    .move-btn {
      display: flex;
      flex-direction: column;
      width: calc(50% - 20px);
      margin: 10px;
      padding: 15px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      transition: all 0.3s ease;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .move-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .move-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    .move-name {
      font-weight: bold;
      color: #fff;
    }
    
    .move-pp {
      color: #4a90e2;
    }
    
    .move-type {
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
    }
    
    .move-description {
      font-size: 0.9em;
      color: #bbb;
    }
    
    /* DE Card Overlay */
    #de-card-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 100%;
    }
    
    .de-card {
      width: 160px;
      height: 220px;
      margin: 15px;
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 12px;
      display: flex;
      flex-direction: column;
      padding: 15px;
      border: 2px solid #4a6fa5;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }
    
    .de-card:hover {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
      border-color: #ff8c00;
    }
    
    .de-card::after {
      content: '';
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0));
      pointer-events: none;
    }
    
    .de-card-header {
      text-align: center;
      margin-bottom: 15px;
      position: relative;
    }
    
    .de-card-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 5px;
    }
    
    .de-card-power {
      position: absolute;
      top: 0;
      right: 0;
      width: 30px;
      height: 30px;
      background: #ff8c00;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      color: #fff;
      font-size: 0.8em;
    }
    
    .de-card-rarity {
      font-size: 0.8em;
      color: #4a90e2;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .de-card-type {
      display: inline-block;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
      margin-top: 5px;
    }
    
    .de-card-description {
      flex: 1;
      display: flex;
      align-items: center;
      text-align: center;
      font-size: 0.9em;
      color: #ddd;
      padding: 5px;
      border-top: 1px solid #4a6fa5;
      margin-top: 10px;
    }
    
    /* Party Overlay */
    #party-info {
      width: 100%;
    }
    
    .party-digimon-card {
      display: flex;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      margin-bottom: 15px;
      padding: 15px;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .party-digimon-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .party-sprite {
      width: 80px;
      height: 80px;
      background-size: cover;
      margin-right: 15px;
      border-radius: 8px;
      background-color: rgba(255,255,255,0.1);
    }
    
    .party-info {
      flex: 1;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }
    
    .party-digimon-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }
    
    .party-digimon-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
    }
    
    .party-digimon-level {
      background: #ff8c00;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: bold;
      color: #fff;
    }
    
    .party-hp {
      margin-bottom: 10px;
    }
    
    .party-hp-bar {
      width: 100%;
      height: 10px;
      background-color: #344a5f;
      border-radius: 10px;
      margin-bottom: 5px;
      overflow: hidden;
    }
    
    .party-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #7ed321, #c8e986);
      width: 65%;
      transition: width 0.5s ease;
    }
    
    .party-hp-text {
      font-size: 0.9em;
      text-align: right;
      color: #ddd;
    }
    
    .party-moves {
      display: flex;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    
    .party-move {
      font-size: 0.8em;
      background: rgba(28, 37, 65, 0.8);
      padding: 3px 8px;
      margin-right: 5px;
      margin-bottom: 5px;
      border-radius: 4px;
      color: #ddd;
    }
    
    .party-actions {
      display: flex;
      justify-content: flex-end;
    }
    
    .party-btn {
      padding: 5px 10px;
      font-size: 0.9em;
    }
    
    /* Item Overlay */
    #item-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    
    .item-card {
      width: 120px;
      margin: 10px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      transition: all 0.3s ease;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .item-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
    }
    
    .item-icon {
      font-size: 2em;
      margin-bottom: 10px;
      color: #ff8c00;
    }
    
    .item-name {
      font-weight: bold;
      margin-bottom: 5px;
      color: #fff;
    }
    
    .item-quantity {
      font-size: 0.9em;
      color: #4a90e2;
      margin-bottom: 10px;
    }
    
    /* DigiScan Overlay */
    .scan-info-container {
      width: 100%;
      max-width: 500px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 20px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }
    
    .scan-header {
      display: flex;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .scan-sprite {
      width: 100px;
      height: 100px;
      background-size: cover;
      margin-right: 20px;
      border-radius: 8px;
      background-color: rgba(255,255,255,0.1);
    }
    
    .scan-basics {
      flex: 1;
    }
    
    .scan-name {
      font-size: 1.3em;
      font-weight: bold;
      color: #fff;
      margin-bottom: 5px;
    }
    
    .scan-details {
      margin-bottom: 20px;
    }
    
    .scan-details p {
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
    }
    
    .scan-label {
      font-weight: bold;
      color: #4a90e2;
    }
    
    .scan-stats {
      display: flex;
      flex-wrap: wrap;
    }
    
    .scan-stat {
      flex: 1 0 50%;
      margin-bottom: 10px;
    }
    
    .scan-moves {
      margin-top: 20px;
    }
    
    .scan-moves-title {
      font-weight: bold;
      color: #4a90e2;
      margin-bottom: 10px;
      border-bottom: 1px solid #4a6fa5;
      padding-bottom: 5px;
    }
    
    .scan-move {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      padding: 5px;
      background: rgba(28, 37, 65, 0.5);
      border-radius: 4px;
    }
    
    /* Rewards & Shop */
    #reward-selection, #shop-screen {
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(10, 15, 30, 0.9);
    }
    
    #reward-selection h2, #shop-screen h2 {
      color: #ff8c00;
      margin-bottom: 20px;
    }
    
    #reward-grid, #shop-items {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 80%;
      margin: 0 auto 20px;
    }
    
    .reward-card, .shop-item-card {
      width: 160px;
      height: 200px;
      margin: 15px;
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      text-align: center;
      border: 2px solid #4a6fa5;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
      cursor: pointer;
    }
    
    .reward-card:hover, .shop-item-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
      border-color: #ff8c00;
    }
    
    .reward-card.selected {
      border-color: #ff8c00;
      box-shadow: 0 0 20px rgba(255, 140, 0, 0.5);
    }
    
    .reward-icon, .shop-icon {
      font-size: 2.5em;
      margin-bottom: 15px;
      color: #ff8c00;
    }
    
    .reward-name, .shop-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 10px;
    }
    
    .reward-description, .shop-description {
      font-size: 0.9em;
      color: #bbb;
      flex: 1;
      display: flex;
      align-items: center;
    }
    
    .shop-price {
      margin-top: 10px;
      background: #ff8c00;
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
      color: #fff;
    }
    
    /* End Run Panel */
    #end-run-panel {
      display: none;
      flex-direction: column;
      align-items: center;
      background: rgba(10, 15, 30, 0.9);
    }
    
    #end-run-panel h2 {
      color: #ff8c00;
      margin-bottom: 30px;
      font-size: 2em;
    }
    
    #end-run-summary {
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 20px;
      width: 80%;
      max-width: 600px;
      text-align: left;
      margin-bottom: 30px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
    }
    
    #end-run-summary h3 {
      color: #4a90e2;
      margin-bottom: 15px;
      border-bottom: 1px solid #4a6fa5;
      padding-bottom: 10px;
    }
    
    .summary-stats {
      margin-bottom: 20px;
    }
    
    .summary-stat {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    .summary-label {
      font-weight: bold;
      color: #ddd;
    }
    
    .summary-value {
      color: #ff8c00;
      font-weight: bold;
    }
    
    .summary-rewards {
      margin-top: 20px;
    }
    
    .summary-reward {
      background: rgba(28, 37, 65, 0.5);
      padding: 10px;
      border-radius: 8px;
      margin-bottom: 10px;
      display: flex;
      justify-content: space-between;
    }

    /* ATTACK ANIMATIONS SYSTEM */

    /* Common Animation Container */
    .attack-animation-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      perspective: 1000px;
    }

    /* Animation Overlay */
    .attack-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.3), rgba(10, 20, 40, 0.5));
      z-index: 1001;
      opacity: 0;
      animation: fadeInOut 1.8s forwards;
    }

    @keyframes fadeInOut {
      0% { opacity: 0; }
      20% { opacity: 0.7; }
      80% { opacity: 0.7; }
      100% { opacity: 0; }
    }

    /* Digital field effect for both animations */
    .attack-digital-field {
      position: absolute;
      width: 100%;
      height: 100%;
      background: linear-gradient(rgba(74, 111, 165, 0.05) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(74, 111, 165, 0.05) 1px, transparent 1px);
      background-size: 20px 20px;
      z-index: 1001;
      opacity: 0;
      animation: digitalFieldPulse 1.8s forwards;
    }

    @keyframes digitalFieldPulse {
      0% { opacity: 0; }
      30% { opacity: 0.5; }
      80% { opacity: 0.5; }
      100% { opacity: 0; }
    }

    /* Digimon sprite representations */
    .attacker-sprite, .target-sprite {
      position: absolute;
      width: 120px;
      height: 120px;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      z-index: 1002;
    }

    .attacker-sprite {
      left: 20%;
      top: 50%;
      transform: translateY(-50%);
    }

    .target-sprite {
      right: 20%;
      top: 50%;
      transform: translateY(-50%) scaleX(-1);
    }

    /* Enemy shake animation */
    @keyframes targetShake {
      0% { transform: translateY(-50%) scaleX(-1) translateX(0); }
      20% { transform: translateY(-50%) scaleX(-1) translateX(-10px); }
      40% { transform: translateY(-50%) scaleX(-1) translateX(8px); }
      60% { transform: translateY(-50%) scaleX(-1) translateX(-6px); }
      80% { transform: translateY(-50%) scaleX(-1) translateX(4px); }
      100% { transform: translateY(-50%) scaleX(-1) translateX(0); }
    }

    /* Flash effect */
    .flash-effect {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0);
      z-index: 1010;
    }

    @keyframes quickFlash {
      0% { background: rgba(255, 255, 255, 0); }
      50% { background: rgba(255, 255, 255, 0.6); }
      100% { background: rgba(255, 255, 255, 0); }
    }

    @keyframes strongFlash {
      0% { background: rgba(255, 255, 255, 0); }
      30% { background: rgba(255, 255, 255, 0.9); }
      100% { background: rgba(255, 255, 255, 0); }
    }

    /* ===== PHYSICAL ATTACK ANIMATIONS ===== */

    /* Attacker movement for physical attack */
    @keyframes attackerLunge {
      0% { transform: translateY(-50%) translateX(0) rotate(0deg); }
      20% { transform: translateY(-50%) translateX(-20px) rotate(-5deg); }
      30% { transform: translateY(-50%) translateX(-10px) rotate(0deg); }
      60% { transform: translateY(-50%) translateX(100px) rotate(5deg); }
      80% { transform: translateY(-50%) translateX(100px) rotate(0deg); }
      100% { transform: translateY(-50%) translateX(0) rotate(0deg); }
    }

    /* Slash effect lines */
    .slash-line {
      position: absolute;
      background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,0.8) 50%, rgba(255,255,255,0) 100%);
      height: 3px;
      width: 0;
      transform-origin: left center;
      box-shadow: 0 0 8px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 140, 0, 0.6);
      border-radius: 2px;
      z-index: 1003;
    }

    @keyframes slashGrow {
      0% { width: 0; opacity: 0; }
      30% { width: 100px; opacity: 1; }
      100% { width: 150px; opacity: 0; }
    }

    /* Impact burst effect */
    .impact-burst {
      position: absolute;
      width: 30px;
      height: 30px;
      background: radial-gradient(circle, rgba(255,255,255,1) 0%, rgba(255,140,0,0.8) 30%, rgba(255,140,0,0) 70%);
      border-radius: 50%;
      top: 50%;
      right: 20%;
      transform: translate(0, -50%) scale(0);
      opacity: 0;
      box-shadow: 0 0 20px rgba(255, 140, 0, 0.6);
      z-index: 1004;
    }

    @keyframes impactBurst {
      0% { transform: translate(0, -50%) scale(0); opacity: 0; }
      30% { transform: translate(0, -50%) scale(2); opacity: 1; }
      100% { transform: translate(0, -50%) scale(4); opacity: 0; }
    }

    /* Digital particles effect */
    .phy-particle {
      position: absolute;
      width: 5px;
      height: 5px;
      background: #ff8c00;
      border-radius: 50%;
      opacity: 0;
      box-shadow: 0 0 10px rgba(255, 140, 0, 0.8);
      z-index: 1005;
    }

    /* ===== SPECIAL ATTACK ANIMATIONS ===== */

    /* Attacker aura effect */
    .attacker-aura {
      position: absolute;
      width: 160px;
      height: 160px;
      left: 20%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0);
      background: radial-gradient(circle, rgba(0,170,255,0.7) 0%, rgba(0,170,255,0.3) 50%, rgba(0,170,255,0) 70%);
      border-radius: 50%;
      box-shadow: 0 0 30px rgba(0, 170, 255, 0.5);
      z-index: 1003;
      opacity: 0;
    }

    @keyframes auraGrow {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.8; }
      100% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.6; }
    }

    /* Energy charge particles */
    .sp-energy-particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #00aaff;
      border-radius: 50%;
      opacity: 0;
      box-shadow: 0 0 10px rgba(0, 170, 255, 0.8);
      z-index: 1004;
    }

    @keyframes particleConverge {
      0% { transform: translate(0, 0) scale(1); opacity: 0; }
      50% { transform: translate(-30px, 0) scale(1.5); opacity: 0.8; }
      100% { transform: translate(-50px, 0) scale(0.5); opacity: 0; }
    }
    
    /* Flipped particle converge animation */
    @keyframes particleConvergeFlipped {
      0% { transform: translate(0, 0) scale(1); opacity: 0; }
      50% { transform: translate(30px, 0) scale(1.5); opacity: 0.8; }
      100% { transform: translate(50px, 0) scale(0.5); opacity: 0; }
    }

    /* Energy beam */
    .energy-beam {
      position: absolute;
      height: 30px;
      background: linear-gradient(90deg, rgba(0,170,255,0.9), rgba(100,200,255,0.9), rgba(255,255,255,0.9), rgba(100,200,255,0.9), rgba(0,170,255,0.9));
      top: 50%;
      left: 25%;
      transform: translateY(-50%);
      transform-origin: left center;
      width: 0;
      box-shadow: 0 0 20px rgba(0, 170, 255, 0.8), 0 0 40px rgba(0, 170, 255, 0.4);
      border-radius: 15px;
      opacity: 0;
      z-index: 1005;
    }

    .beam-pattern {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(90deg, transparent 0%, transparent 30%, rgba(255,255,255,0.5) 50%, transparent 70%, transparent 100%),
        repeating-linear-gradient(90deg, transparent, transparent 10px, rgba(0,0,0,0.1) 10px, rgba(0,0,0,0.1) 20px);
      background-size: 100% 100%, 20px 20px;
      opacity: 0.7;
      animation: patternMove 1s linear infinite;
    }

    @keyframes patternMove {
      0% { background-position: 0 0, 0 0; }
      100% { background-position: 100px 0, 20px 0; }
    }

    @keyframes beamExtend {
      0% { width: 0; opacity: 0.3; }
      50% { width: 50%; opacity: 1; }
      100% { width: 45%; opacity: 0.9; }
    }
    
    /* Flipped beam extend animation */
    @keyframes beamExtendFlipped {
      0% { width: 0; opacity: 0.3; }
      50% { width: 50%; opacity: 1; }
      100% { width: 45%; opacity: 0.9; }
    }

    /* Impact explosion */
    .impact-explosion {
      position: absolute;
      width: 0;
      height: 0;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(100,200,255,0.8) 30%, rgba(0,170,255,0.7) 60%, rgba(0,170,255,0) 100%);
      border-radius: 50%;
      top: 50%;
      right: 20%;
      transform: translate(0, -50%);
      opacity: 0;
      box-shadow: 0 0 40px rgba(0, 170, 255, 0.8), 0 0 80px rgba(0, 170, 255, 0.4);
      z-index: 1006;
    }

    @keyframes explosionGrow {
      0% { width: 0; height: 0; opacity: 0.5; }
      50% { width: 120px; height: 120px; opacity: 1; }
      100% { width: 150px; height: 150px; opacity: 0; }
    }

    /* Digital fragments */
    .digital-fragment {
      position: absolute;
      width: 10px;
      height: 10px;
      background: linear-gradient(135deg, #00aaff, #80d0ff);
      top: 50%;
      right: 20%;
      transform: translate(0, -50%) rotate(0deg);
      opacity: 0;
      box-shadow: 0 0 10px rgba(0, 170, 255, 0.8);
      z-index: 1007;
    }
    
    /* DigiCrystal Shop & Digivice Storage */
    #digicrystal-shop-panel, #digivice-storage-panel {
      display: none;
      overflow-y: auto;
    }
    
    .shop-header, .storage-header {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .shop-currency {
      display: flex;
      align-items: center;
      padding: 5px 15px;
      background: rgba(255, 140, 0, 0.2);
      border-radius: 20px;
      border: 1px solid #ff8c00;
    }
    
    .shop-currency-icon {
      color: #ff8c00;
      margin-right: 10px;
      font-size: 1.2em;
    }
    
    .shop-currency-amount {
      font-weight: bold;
      color: #ff8c00;
    }
    
    #digicrystal-upgrades {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 90%;
      max-width: 800px;
    }
    
    .upgrade-card {
      width: 200px;
      margin: 15px;
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      padding: 20px;
      text-align: center;
      border: 2px solid #4a6fa5;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .upgrade-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
    }
    
    .upgrade-icon {
      font-size: 2em;
      margin-bottom: 15px;
      color: #4a90e2;
    }
    
    .upgrade-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 10px;
    }
    
    .upgrade-description {
      font-size: 0.9em;
      color: #bbb;
      flex: 1;
      margin-bottom: 15px;
    }
    
    .upgrade-cost {
      background: #ff8c00;
      padding: 5px 10px;
      border-radius: 15px;
      font-weight: bold;
      color: #fff;
      display: inline-block;
      margin-bottom: 10px;
    }
    
    /* Digivice Storage */
    #variant-filters {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 20px;
      width: 90%;
      max-width: 800px;
    }
    
    #variant-filters button {
      margin: 5px;
    }
    
    .filter-active {
      background: linear-gradient(135deg, #ff8c00, #f76b1c);
      box-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
    }
    
    .sort-bar {
      margin: 15px 0;
      width: 90%;
      max-width: 800px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-wrap: wrap;
    }
    
    .sort-label {
      margin-right: 10px;
      color: #ddd;
    }
    
    #storage-digimon-grid {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 90%;
      max-width: 800px;
    }
    
    .caught-digi-card {
      width: 220px;
      margin: 15px;
      background: linear-gradient(135deg, #1c2541, #0b132b);
      border-radius: 8px;
      padding: 15px;
      text-align: left;
      font-size: 0.9em;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .caught-digi-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
    }
    
    .caught-digi-header {
      display: flex;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .caught-digi-sprite {
      width: 60px;
      height: 60px;
      background-size: cover;
      margin-right: 15px;
      border-radius: 8px;
      background-color: rgba(255,255,255,0.1);
    }
    
    .caught-digi-info {
      flex: 1;
    }
    
    .caught-digi-name {
      font-weight: bold;
      font-size: 1.1em;
      color: #fff;
      margin-bottom: 5px;
    }
    
    .caught-digi-id {
      font-size: 0.8em;
      color: #4a90e2;
    }
    
    .caught-digi-details p {
      margin: 5px 0;
      display: flex;
      justify-content: space-between;
    }
    
    .caught-digi-label {
      color: #ddd;
    }
    
    .caught-digi-value {
      font-weight: bold;
      color: #fff;
    }
    
    .caught-digi-value.variant-normal {
      color: #ddd;
    }
    
    .caught-digi-value.variant-chroma {
      color: #4a90e2;
    }
    
    .caught-digi-value.variant-prisma {
      color: #c862e2;
      text-shadow: 0 0 5px rgba(200, 98, 226, 0.5);
    }
    
    .caught-digi-value.variant-stella {
      color: #ffc107;
      text-shadow: 0 0 5px rgba(255, 193, 7, 0.5);
    }
    
    /* Battle Arena Placeholder */
    #battle-arena-panel {
      display: none;
      background: url('https://images.unsplash.com/photo-1596508559853-8014d856d2ce?q=80&w=2070&auto=format&fit=crop') no-repeat center center;
      background-size: cover;
      position: relative;
    }
    
    #battle-arena-panel::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(10, 15, 30, 0.8);
    }
    
    .arena-content {
      position: relative;
      z-index: 1;
      text-align: center;
      max-width: 600px;
    }
    
    .arena-title {
      font-size: 2em;
      color: #ff8c00;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
    }
    
    .arena-description {
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 20px;
      margin-bottom: 30px;
      box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
      line-height: 1.6;
    }
    
    /* Move Learn Overlay */
    #move-learn-overlay {
      background: rgba(10, 15, 30, 0.95);
    }
    
    #move-learn-overlay .overlay-content {
      max-width: 600px;
    }
    
    #learn-move-description {
      margin-bottom: 20px;
      line-height: 1.5;
    }
    
    #current-moves {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      margin-bottom: 20px;
    }
    
    .current-move {
      width: calc(50% - 20px);
      margin: 10px;
      background: rgba(28, 37, 65, 0.8);
      border-radius: 8px;
      padding: 15px;
      transition: all 0.3s ease;
      cursor: pointer;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    
    .current-move:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
      background: rgba(40, 50, 80, 0.8);
    }
    
    .move-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
    }
    
    #new-move {
      margin: 20px 0;
      padding: 15px;
      background: rgba(255, 140, 0, 0.2);
      border: 1px solid #ff8c00;
      border-radius: 8px;
      font-weight: bold;
      color: #ff8c00;
    }
    
    /* Responsive adjustments */
    @media (max-width: 768px) {
      .digimon-starter-card {
        width: 120px;
        height: 160px;
      }
      
      .digivice-option {
        width: 120px;
        height: 80px;
      }
      
      .battle-top {
        flex-direction: column;
        align-items: center;
      }
      
      .digimon-battle-container {
        width: 90%;
        margin-bottom: 15px;
      }
      
      .enemy-container {
        order: 1;
      }
      
      .player-container {
        order: 2;
      }
      
      .battle-actions .digimon-btn {
        flex: 1 0 calc(50% - 10px);
      }
      
      .move-btn, .current-move {
        width: 100%;
      }
      
      .reward-card, .shop-item-card, .upgrade-card, .caught-digi-card {
        width: calc(50% - 20px);
      }
    }
    
    @media (max-width: 480px) {
      #title-screen h1 {
        font-size: 2em;
      }
      
      .digimon-starter-card {
        width: 100px;
        height: 140px;
      }
      
      .digivice-option {
        width: 100px;
        height: 70px;
      }
      
      .battle-actions .digimon-btn {
        flex: 1 0 calc(100% - 10px);
      }
      
      .reward-card, .shop-item-card, .upgrade-card, .caught-digi-card {
        width: 100%;
      }
    }

    /* PREMIUM DE STRIKE ANIMATION SYSTEM */
    .de-strike-animation-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1000;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      perspective: 2000px;
      overflow: hidden;
    }

    /* Phase 1: Reality Fracture Overlay */
    .reality-fracture-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 30% 70%, rgba(0, 100, 255, 0.3) 0%, transparent 50%),
        radial-gradient(circle at 70% 30%, rgba(255, 0, 150, 0.3) 0%, transparent 50%),
        linear-gradient(45deg, rgba(0, 0, 0, 0.7), rgba(20, 20, 40, 0.9));
      z-index: 1001;
      opacity: 0;
      animation: realityFracture 4.5s forwards;
    }

    @keyframes realityFracture {
      0% { 
        opacity: 0;
        filter: blur(0px) hue-rotate(0deg);
      }
      15% { 
        opacity: 1;
        filter: blur(2px) hue-rotate(90deg);
      }
      30% {
        opacity: 0.8;
        filter: blur(0px) hue-rotate(180deg);
      }
      85% { 
        opacity: 0.9;
        filter: blur(1px) hue-rotate(270deg);
      }
      100% { 
        opacity: 0;
        filter: blur(0px) hue-rotate(360deg);
      }
    }

    /* Phase 2: Digital Glitch Matrix */
    .glitch-matrix {
      position: absolute;
      width: 100%;
      height: 100%;
      background-image: 
        linear-gradient(90deg, transparent 0%, rgba(0, 255, 255, 0.1) 50%, transparent 100%),
        linear-gradient(0deg, transparent 0%, rgba(255, 0, 255, 0.1) 50%, transparent 100%);
      background-size: 20px 20px, 15px 15px;
      z-index: 1002;
      opacity: 0;
      animation: glitchMatrix 4.5s forwards;
      transform: scale(1);
    }

    @keyframes glitchMatrix {
      0% { 
        opacity: 0;
        transform: scale(1) rotate(0deg);
        background-position: 0 0, 0 0;
      }
      10% { 
        opacity: 0.6;
        transform: scale(1.02) rotate(0.5deg);
      }
      20% {
        opacity: 0.4;
        transform: scale(0.98) rotate(-0.5deg);
        background-position: 100px 0, 0 100px;
      }
      80% { 
        opacity: 0.3;
        transform: scale(1.01) rotate(0deg);
        background-position: 200px 200px, 150px 150px;
      }
      100% { 
        opacity: 0;
        transform: scale(1) rotate(0deg);
      }
    }

    /* Phase 3: Holographic Card Materialization */
    .holo-card-container {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 280px;
      z-index: 1003;
      perspective: 1500px;
    }

    .holo-card {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      opacity: 0;
      transform: rotateX(90deg) rotateY(45deg) scale(0.5);
      animation: holoCardMaterialize 4.5s forwards;
    }

    @keyframes holoCardMaterialize {
      0% {
        opacity: 0;
        transform: rotateX(90deg) rotateY(45deg) scale(0.5);
      }
      20% {
        opacity: 0.3;
        transform: rotateX(45deg) rotateY(25deg) scale(0.7);
      }
      35% {
        opacity: 0.8;
        transform: rotateX(10deg) rotateY(5deg) scale(0.9);
      }
      50% {
        opacity: 1;
        transform: rotateX(0deg) rotateY(0deg) scale(1);
      }
      65% {
        opacity: 0.9;
        transform: rotateX(-10deg) rotateY(-5deg) scale(1.1);
      }
      80% {
        opacity: 0.7;
        transform: rotateX(-30deg) rotateY(-15deg) scale(0.8);
      }
      100% {
        opacity: 0;
        transform: rotateX(-90deg) rotateY(-45deg) scale(0.3);
      }
    }

    .card-front {
      position: absolute;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(135deg, 
          rgba(0, 150, 255, 0.9) 0%, 
          rgba(100, 200, 255, 0.95) 25%,
          rgba(255, 255, 255, 1) 50%,
          rgba(100, 200, 255, 0.95) 75%,
          rgba(0, 150, 255, 0.9) 100%);
      border-radius: 15px;
      border: 3px solid rgba(255, 255, 255, 0.8);
      box-shadow: 
        0 0 30px rgba(0, 150, 255, 0.8),
        inset 0 0 20px rgba(255, 255, 255, 0.3),
        0 0 60px rgba(0, 150, 255, 0.4);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-family: var(--font-primary);
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    .card-front::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: 
        radial-gradient(circle, rgba(255, 255, 255, 0.3) 0%, transparent 70%),
        linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
      animation: holoShimmer 2s linear infinite;
    }

    @keyframes holoShimmer {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .card-title {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 10px;
      text-align: center;
      letter-spacing: 1px;
    }

    .card-symbol {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.9), rgba(0, 150, 255, 0.7));
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      margin-bottom: 15px;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.6);
    }

    .card-type-badge {
      background: rgba(0, 0, 0, 0.7);
      padding: 5px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: bold;
      border: 1px solid rgba(255, 255, 255, 0.5);
    }

    /* Phase 4: Quantum Data Streams */
    .quantum-stream-container {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 1002;
      overflow: hidden;
    }

    .data-stream {
      position: absolute;
      width: 3px;
      background: linear-gradient(180deg, 
        transparent 0%, 
        rgba(0, 255, 255, 0.8) 20%, 
        rgba(0, 150, 255, 1) 50%, 
        rgba(0, 255, 255, 0.8) 80%, 
        transparent 100%);
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
      opacity: 0;
    }

    .stream-1 { 
      left: 10%; 
      height: 200px; 
      animation: dataStreamFlow 4.5s forwards;
      animation-delay: 0.5s;
    }
    .stream-2 { 
      left: 25%; 
      height: 150px; 
      animation: dataStreamFlow 4.5s forwards;
      animation-delay: 0.7s;
    }
    .stream-3 { 
      left: 40%; 
      height: 250px; 
      animation: dataStreamFlow 4.5s forwards;
      animation-delay: 0.3s;
    }
    .stream-4 { 
      left: 60%; 
      height: 180px; 
      animation: dataStreamFlow 4.5s forwards;
      animation-delay: 0.9s;
    }
    .stream-5 { 
      left: 75%; 
      height: 220px; 
      animation: dataStreamFlow 4.5s forwards;
      animation-delay: 0.6s;
    }
    .stream-6 { 
      left: 90%; 
      height: 160px; 
      animation: dataStreamFlow 4.5s forwards;
      animation-delay: 0.4s;
    }

    @keyframes dataStreamFlow {
      0% {
        opacity: 0;
        top: 100%;
        transform: scaleY(0);
      }
      15% {
        opacity: 0.8;
        top: 80%;
        transform: scaleY(0.3);
      }
      50% {
        opacity: 1;
        top: 20%;
        transform: scaleY(1);
      }
      80% {
        opacity: 0.6;
        top: -20%;
        transform: scaleY(0.7);
      }
      100% {
        opacity: 0;
        top: -50%;
        transform: scaleY(0);
      }
    }

    /* Phase 5: Holographic UI Overlay */
    .holo-ui-overlay {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 1004;
      opacity: 0;
      animation: holoUIActivate 4.5s forwards;
    }

    @keyframes holoUIActivate {
      0% { opacity: 0; }
      40% { opacity: 0; }
      50% { opacity: 1; }
      75% { opacity: 0.8; }
      100% { opacity: 0; }
    }

    .scan-line {
      position: absolute;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(0, 255, 255, 0.8) 20%, 
        rgba(255, 255, 255, 1) 50%, 
        rgba(0, 255, 255, 0.8) 80%, 
        transparent 100%);
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
      top: 50%;
      animation: scanLineMove 2s ease-in-out infinite;
    }

    @keyframes scanLineMove {
      0% { transform: translateY(-100px); opacity: 0; }
      50% { transform: translateY(0px); opacity: 1; }
      100% { transform: translateY(100px); opacity: 0; }
    }

    .ui-corner {
      position: absolute;
      width: 40px;
      height: 40px;
      border: 2px solid rgba(0, 255, 255, 0.8);
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.6);
    }

    .ui-corner.top-left {
      top: 20%;
      left: 20%;
      border-bottom: none;
      border-right: none;
    }

    .ui-corner.top-right {
      top: 20%;
      right: 20%;
      border-bottom: none;
      border-left: none;
    }

    .ui-corner.bottom-left {
      bottom: 20%;
      left: 20%;
      border-top: none;
      border-right: none;
    }

    .ui-corner.bottom-right {
      bottom: 20%;
      right: 20%;
      border-top: none;
      border-left: none;
    }

    /* Phase 6: Dimensional Tear Effect */
    .dimensional-tear {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 300px;
      background: linear-gradient(90deg,
        transparent 0%,
        rgba(255, 255, 255, 0.3) 40%,
        rgba(0, 255, 255, 0.8) 50%,
        rgba(255, 255, 255, 0.3) 60%,
        transparent 100%);
      box-shadow: 
        0 0 50px rgba(0, 255, 255, 0.8),
        inset 0 0 30px rgba(255, 255, 255, 0.5);
      z-index: 1005;
      opacity: 0;
      animation: dimensionalTear 4.5s forwards;
    }

    @keyframes dimensionalTear {
      0% {
        opacity: 0;
        width: 0;
        filter: blur(10px);
      }
      55% {
        opacity: 0;
        width: 0;
      }
      65% {
        opacity: 1;
        width: 100px;
        filter: blur(3px);
      }
      75% {
        opacity: 0.8;
        width: 150px;
        filter: blur(0px);
      }
      85% {
        opacity: 0.6;
        width: 100px;
        filter: blur(5px);
      }
      100% {
        opacity: 0;
        width: 0;
        filter: blur(15px);
      }
    }

    /* Phase 7: Energy Convergence */
    .energy-convergence {
      position: absolute;
      left: 30%;
      top: 50%;
      transform: translateY(-50%);
      width: 40%;
      height: 20px;
      z-index: 1006;
      opacity: 0;
      animation: energyConvergence 4.5s forwards;
    }

    @keyframes energyConvergence {
      0% { opacity: 0; }
      70% { opacity: 0; }
      75% { 
        opacity: 1;
        background: linear-gradient(90deg, 
          rgba(0, 255, 255, 0.9), 
          rgba(255, 255, 255, 1), 
          rgba(0, 150, 255, 0.9));
        box-shadow: 0 0 30px rgba(0, 255, 255, 1);
      }
      90% { 
        opacity: 0.7;
        background: linear-gradient(90deg, 
          rgba(255, 100, 100, 0.9), 
          rgba(255, 255, 255, 1), 
          rgba(255, 150, 0, 0.9));
        box-shadow: 0 0 50px rgba(255, 100, 0, 1);
      }
      100% { opacity: 0; }
    }

    /* Phase 8: Reality Reconstruction */
    .reality-reconstruction {
      position: absolute;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 50% 50%, 
          rgba(255, 255, 255, 0.1) 0%, 
          transparent 50%);
      z-index: 1007;
      opacity: 0;
      animation: realityReconstruction 4.5s forwards;
    }

    @keyframes realityReconstruction {
      0% { 
        opacity: 0; 
        transform: scale(0.5);
        filter: brightness(1);
      }
      80% { opacity: 0; }
      85% { 
        opacity: 1; 
        transform: scale(2);
        filter: brightness(3);
      }
      95% { 
        opacity: 0.5; 
        transform: scale(3);
        filter: brightness(1.5);
      }
      100% { 
        opacity: 0; 
        transform: scale(5);
        filter: brightness(1);
      }
    }

    /* Phase 9: Screen Distortion */
    .screen-distortion {
      position: absolute;
      width: 100%;
      height: 100%;
      z-index: 1008;
      opacity: 0;
      background: 
        repeating-linear-gradient(0deg,
          transparent 0px,
          rgba(255, 255, 255, 0.03) 1px,
          transparent 2px);
      animation: screenDistortion 4.5s forwards;
    }

    @keyframes screenDistortion {
      0% { 
        opacity: 0;
        transform: skew(0deg);
      }
      85% { opacity: 0; }
      88% { 
        opacity: 0.6;
        transform: skew(2deg);
      }
      91% { 
        opacity: 0.8;
        transform: skew(-1deg);
      }
      94% { 
        opacity: 0.4;
        transform: skew(1deg);
      }
      100% { 
        opacity: 0;
        transform: skew(0deg);
      }
    }

    /* Premium Text Effects */
    .premium-text {
      position: absolute;
      font-family: var(--font-primary);
      font-weight: 900;
      color: rgba(255, 255, 255, 0.95);
      text-shadow: 
        0 0 20px rgba(0, 255, 255, 0.8),
        0 0 40px rgba(0, 150, 255, 0.6),
        0 2px 4px rgba(0, 0, 0, 0.5);
      z-index: 1009;
      opacity: 0;
      letter-spacing: 3px;
    }

    .de-activate-text {
      top: 25%;
      left: 50%;
      font-size: clamp(24px, 5vw, 36px);
      transform: translate(-50%, -50%) scale(0.5) rotateY(90deg);
      animation: premiumTextAppear 1.2s forwards;
      animation-delay: 1.5s;
    }

    .system-override-text {
      top: 75%;
      left: 50%;
      font-size: clamp(28px, 6vw, 42px);
      transform: translate(-50%, -50%) scale(0.5) rotateX(90deg);
      animation: premiumTextAppear 1.2s forwards;
      animation-delay: 2.5s;
    }

    @keyframes premiumTextAppear {
      0% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.5) rotateY(90deg);
        filter: blur(10px);
      }
      30% { 
        opacity: 0.8; 
        transform: translate(-50%, -50%) scale(1.2) rotateY(0deg);
        filter: blur(2px);
      }
      60% { 
        opacity: 1; 
        transform: translate(-50%, -50%) scale(1) rotateY(0deg);
        filter: blur(0px);
      }
      90% { 
        opacity: 0.7; 
        transform: translate(-50%, -50%) scale(0.9) rotateY(0deg);
        filter: blur(1px);
      }
      100% { 
        opacity: 0; 
        transform: translate(-50%, -50%) scale(0.3) rotateY(-90deg);
        filter: blur(5px);
      }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <!-- TITLE SCREEN -->
    <div id="title-screen" class="panel">
      <h1>Digimon Rogue-Like</h1>
      <div class="digivice-animation"></div>
      <p id="press-to-continue">Press Anywhere to Continue</p>
    </div>

    <!-- MAIN MENU -->
    <div id="main-menu" class="panel scrollable" style="display:none;">
      <h2>Main Menu</h2>
      <div class="menu-options">
        <button class="digimon-btn" onclick="newRun()">New Run</button>
        <button class="digimon-btn" onclick="loadRun()">Load Run</button>
        <button class="digimon-btn" onclick="openDigiCrystalShop()">DigiCrystal Shop</button>
        <button class="digimon-btn" onclick="openDigiviceStorage()">Digivice Storage</button>
        <button class="digimon-btn" onclick="openBattleArena()">Digimon Battle Arena (Placeholder)</button>
      </div>
    </div>

    <!-- CHARACTER SELECT -->
    <div id="character-select" class="panel scrollable" style="display:none;">
      <h2>Select Starter Digimon (1-3)</h2>
      <div id="starter-digimon-grid"></div>

      <h3>Select Your Digivice</h3>
      <div id="digivice-selection"></div>

      <div style="margin-top:20px;">
        <button class="digimon-btn" onclick="confirmStarters()">Confirm Starters</button>
        <button class="digimon-btn" onclick="backToMainMenu()">Back</button>
      </div>
    </div>

    <!-- PREMIUM BATTLE SCREEN -->
    <div id="battle-screen">
      <div id="battle-header">
        <div class="gold-info">💰 <span id="gold-display">0</span></div>
        <div class="round-info">Round: <span id="round-display">1</span></div>
      </div>
      
      <div class="battle-main">
        <div class="battle-top">
          <div class="digimon-battle-container player-container">
            <div class="digimon-info">
              <div class="digimon-name">
                <h3 id="player-digimon-name">Agumon</h3>
                <span id="player-digimon-type" class="digimon-type type-data">Data</span>
              </div>
              <div class="hp-section">
                <div class="hp-bar">
                  <div id="player-hp-fill" class="hp-fill"></div>
                </div>
                <div class="hp-text">
                  <span id="player-hp-text">40/40</span>
                </div>
              </div>
              <div class="level-info">Lv. <span id="player-level">5</span></div>
              <div class="exp-bar">
                <div id="player-exp-fill" class="exp-fill"></div>
              </div>
            </div>
            <div class="digimon-sprite-container">
              <div id="player-digimon-sprite" class="digimon-sprite player-sprite"></div>
            </div>
          </div>
          
          <div class="digimon-battle-container enemy-container">
            <div class="digimon-info">
              <div class="digimon-name">
                <h3 id="enemy-digimon-name">Gabumon</h3>
                <span id="enemy-digimon-type" class="digimon-type type-vaccine">Vaccine</span>
              </div>
              <div class="hp-section">
                <div class="hp-bar">
                  <div id="enemy-hp-fill" class="hp-fill"></div>
                </div>
                <div class="hp-text">
                  <span id="enemy-hp-text">35/35</span>
                </div>
              </div>
              <div class="level-info">Lv. <span id="enemy-level">5</span></div>
            </div>
            <div class="digimon-sprite-container">
              <div id="enemy-digimon-sprite" class="digimon-sprite enemy-sprite"></div>
            </div>
          </div>
        </div>
        
        <div class="battle-log-container">
          <div class="battle-log scrollable" id="battle-log"></div>
        </div>
        
        <div class="battle-actions">
          <button class="digimon-btn" onclick="selectMoveAction()">Fight</button>
          <button class="digimon-btn" onclick="openDECardOverlay()">DE Strike</button>
          <button class="digimon-btn" onclick="openPartyOverlay()">Party</button>
          <button class="digimon-btn" onclick="openItemOverlay()">Items</button>
          <button class="digimon-btn" onclick="openCaptureOverlay()">Capture</button>
          <button class="digimon-btn" onclick="openScanOverlay()">DigiScan</button>
        </div>
      </div>
    </div>

    <!-- MOVE SELECTION -->
    <div id="move-selection-overlay" class="overlay scrollable">
      <button class="digimon-btn close-btn" onclick="closeMoveSelection()">X</button>
      <h2>Select a Move</h2>
      <div class="overlay-content">
        <div id="move-selection-list"></div>
      </div>
    </div>

    <!-- DE CARD OVERLAY -->
    <div id="de-card-overlay" class="overlay scrollable">
      <button class="digimon-btn close-btn" onclick="closeDECardOverlay()">X</button>
      <h2>Digicard Library</h2>
      <div class="overlay-content">
        <p>Select a DE Card to use.</p>
        <div id="de-card-list"></div>
      </div>
    </div>

    <!-- PARTY OVERLAY -->
    <div id="party-overlay" class="overlay scrollable">
      <button class="digimon-btn close-btn" onclick="closePartyOverlay()">X</button>
      <h2>Your Party</h2>
      <div class="overlay-content">
        <div id="party-info"></div>
      </div>
    </div>

    <!-- ITEM OVERLAY -->
    <div id="item-overlay" class="overlay scrollable">
      <button class="digimon-btn close-btn" onclick="closeItemOverlay()">X</button>
      <h2>Items</h2>
      <div class="overlay-content">
        <div id="item-list"></div>
      </div>
    </div>

    <!-- CAPTURE OVERLAY -->
    <div id="capture-overlay" class="overlay scrollable">
      <button class="digimon-btn close-btn" onclick="closeCaptureOverlay()">X</button>
      <h2>Capture Digimon</h2>
      <div class="overlay-content">
        <p>Use a DigiHex to attempt capture.</p>
        <div id="digihex-options"></div>
      </div>
    </div>

    <!-- DIGISCAN OVERLAY -->
    <div id="scan-overlay" class="overlay scrollable">
      <button class="digimon-btn close-btn" onclick="closeScanOverlay()">X</button>
      <h2>DigiScan</h2>
      <div class="overlay-content">
        <div id="scan-info"></div>
      </div>
    </div>

    <!-- MOVE LEARN OVERLAY -->
    <div id="move-learn-overlay" class="overlay scrollable">
      <button class="digimon-btn close-btn" onclick="closeMoveLearnOverlay()">X</button>
      <div class="overlay-content">
        <h2>Learn a New Move</h2>
        <p id="learn-move-description"></p>
        <div id="current-moves"></div>
        <div id="new-move"></div>
        <button class="digimon-btn" onclick="replaceMoveConfirm(-1)">Skip</button>
      </div>
    </div>

    <!-- REWARD SELECTION -->
    <div id="reward-selection" class="panel scrollable">
      <h2>Choose Your Reward(s)</h2>
      <div id="reward-grid"></div>
      <button class="digimon-btn" onclick="confirmRewardSelection()">Confirm</button>
    </div>

    <!-- SHOP SCREEN -->
    <div id="shop-screen" class="panel scrollable">
      <h2>Shop</h2>
      <div class="gold-info">💰 <span id="shop-gold-display">0</span></div>
      <div id="shop-items"></div>
      <button class="digimon-btn" onclick="closeShop()">Exit Shop</button>
    </div>

    <!-- END-RUN PANEL -->
    <div id="end-run-panel" class="panel scrollable">
      <h2>Run Ended</h2>
      <div id="end-run-summary">
        <h3>Run Summary</h3>
        <div class="summary-stats">
          <div class="summary-stat">
            <span class="summary-label">Rounds Completed:</span>
            <span id="summary-rounds" class="summary-value">0</span>
          </div>
          <div class="summary-stat">
            <span class="summary-label">Digimon Captured:</span>
            <span id="summary-captures" class="summary-value">0</span>
          </div>
          <div class="summary-stat">
            <span class="summary-label">Gold Earned:</span>
            <span id="summary-gold" class="summary-value">0</span>
          </div>
        </div>
        
        <div class="summary-rewards">
          <h4>Permanent Rewards:</h4>
          <div class="summary-reward">
            <span>DigiCrystals:</span>
            <span id="summary-crystals" class="summary-value">0</span>
          </div>
        </div>
      </div>
      <button class="digimon-btn" onclick="returnToMainMenu()">Return to Main Menu</button>
    </div>

    <!-- DIGICRYSTAL SHOP -->
    <div id="digicrystal-shop-panel" class="panel scrollable">
      <div class="shop-header">
        <h2>DigiCrystal Shop</h2>
        <div class="shop-currency">
          <span class="shop-currency-icon">💎</span>
          <span id="meta-digicrystals-count" class="shop-currency-amount">0</span>
        </div>
      </div>
      <div id="digicrystal-upgrades"></div>
      <button class="digimon-btn" onclick="closeDigiCrystalShop()">Back</button>
    </div>

    <!-- DIGIVICE STORAGE (GLOBAL MEMORY) -->
    <div id="digivice-storage-panel" class="panel scrollable">
      <div class="storage-header">
        <h2>Digivice Storage</h2>
        <div><span id="storage-count">0</span> Digimon caught</div>
      </div>
      
      <p>All Digimon you have caught across all runs are listed here.</p>

      <!-- Variant filter buttons -->
      <div id="variant-filters">
        <button class="digimon-btn filter-active" onclick="setVariantFilter('All')">All</button>
        <button class="digimon-btn" onclick="setVariantFilter('Normal')">Normal</button>
        <button class="digimon-btn" onclick="setVariantFilter('Chroma')">Chroma</button>
        <button class="digimon-btn" onclick="setVariantFilter('Prisma')">Prisma</button>
        <button class="digimon-btn" onclick="setVariantFilter('Stella')">Stella</button>
      </div>

      <div class="sort-bar">
        <span class="sort-label">Sort by:</span>
        <button class="digimon-btn" onclick="sortCaughtDigimon('id')">ID</button>
        <button class="digimon-btn" onclick="sortCaughtDigimon('name')">Name</button>
        <button class="digimon-btn" onclick="sortCaughtDigimon('stage')">Stage</button>
        <button class="digimon-btn" onclick="sortCaughtDigimon('level')">Level</button>
      </div>

      <div id="storage-digimon-grid"></div>

      <button class="digimon-btn" style="margin-top:20px;" onclick="closeDigiviceStorage()">Close</button>
    </div>

    <!-- BATTLE ARENA PLACEHOLDER -->
    <div id="battle-arena-panel" class="panel scrollable">
      <div class="arena-content">
        <h2 class="arena-title">Digimon Battle Arena</h2>
        <div class="arena-description">
          <p>This is a placeholder for a future PVP or advanced battle mode. Here you'll be able to battle against other tamers and earn special rewards.</p>
          <p>Feature coming in a future update!</p>
        </div>
        <button class="digimon-btn" onclick="closeBattleArena()">Close</button>
      </div>
    </div>
  </div>

  <script>
    /* ATTACK ANIMATION SYSTEM */

    // Main function for physical attack animation (for moves that scale off ATK)
    function playPhysicalAttackAnimation(attacker, target, moveName, callback) {
      // Create animation container
      const container = document.createElement('div');
      container.className = 'attack-animation-container';
      document.body.appendChild(container);
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.className = 'attack-overlay';
      container.appendChild(overlay);
      
      // Create digital field
      const digitalField = document.createElement('div');
      digitalField.className = 'attack-digital-field';
      container.appendChild(digitalField);
      
      // Determine if we need to flip the animation (enemy attacking player)
      // If the attacker is an enemy (i.e., not in the player's party), flip = true
      const flip = !gameState.party.some(digimon => digimon.uniqueID === attacker.uniqueID);
      
      // Create sprite representations with positions based on flip parameter
      const attackerSprite = document.createElement('div');
      attackerSprite.className = 'attacker-sprite';
      attackerSprite.style.backgroundImage = `url(${attacker.spriteUrl})`;
      
      const targetSprite = document.createElement('div');
      targetSprite.className = 'target-sprite';
      targetSprite.style.backgroundImage = `url(${target.spriteUrl})`;
      
      if (flip) {
        // Flip positions for enemy attacking player
        attackerSprite.style.left = 'auto';
        attackerSprite.style.right = '20%';
        attackerSprite.style.transform = 'translateY(-50%) scaleX(-1)';
        
        targetSprite.style.right = 'auto';
        targetSprite.style.left = '20%';
        targetSprite.style.transform = 'translateY(-50%)';
      }
      
      container.appendChild(attackerSprite);
      container.appendChild(targetSprite);
      
      // Create slash effects with position based on flip parameter
      for (let i = 0; i < 3; i++) {
        const slashLine = document.createElement('div');
        slashLine.className = 'slash-line';
        const verticalOffset = -15 + (i * 15); // -15px, 0px, +15px
        slashLine.style.top = `calc(50% + ${verticalOffset}px)`;
        
        if (flip) {
          slashLine.style.left = `20%`;
          slashLine.style.transform = `rotate(${-(i-1) * 20}deg)`;
        } else {
          slashLine.style.right = `20%`;
          slashLine.style.transform = `rotate(${(i-1) * 20}deg)`;
        }
        
        container.appendChild(slashLine);
      }
      
      // Create impact burst with position based on flip parameter
      const impactBurst = document.createElement('div');
      impactBurst.className = 'impact-burst';
      if (flip) {
        impactBurst.style.right = 'auto';
        impactBurst.style.left = '20%';
      }
      container.appendChild(impactBurst);
      
      // Create particles with positions based on flip parameter
      for (let i = 0; i < 10; i++) {
        const particle = document.createElement('div');
        particle.className = 'phy-particle';
        
        if (flip) {
          particle.style.top = `calc(50% + ${Math.random() * 40 - 20}px)`;
          particle.style.left = `calc(20% + ${Math.random() * 30 - 15}px)`;
          particle.style.right = 'auto';
        } else {
          particle.style.top = `calc(50% + ${Math.random() * 40 - 20}px)`;
          particle.style.right = `calc(20% + ${Math.random() * 30 - 15}px)`;
        }
        
        container.appendChild(particle);
      }
      
      // Create flash effect
      const flashEffect = document.createElement('div');
      flashEffect.className = 'flash-effect';
      container.appendChild(flashEffect);
      
      // Animation sequence
      setTimeout(() => {
        // 1. Attacker lunges forward
        if (flip) {
          attackerSprite.style.animation = 'attackerLungeFlipped 1.2s ease-in-out forwards';
        } else {
          attackerSprite.style.animation = 'attackerLunge 1.2s ease-in-out forwards';
        }
        
        // 2. After a slight delay, show slash effects
        setTimeout(() => {
          const slashLines = document.querySelectorAll('.slash-line');
          slashLines.forEach((slash, index) => {
            if (flip) {
              slash.style.animation = `slashGrowFlipped 0.4s ${index * 0.1}s ease-out forwards`;
            } else {
              slash.style.animation = `slashGrow 0.4s ${index * 0.1}s ease-out forwards`;
            }
          });
          
          // Quick flash
          flashEffect.style.animation = 'quickFlash 0.3s ease-out';
          
          // 3. Show impact burst and shake target
          setTimeout(() => {
            if (flip) {
              impactBurst.style.animation = 'impactBurstFlipped 0.4s ease-out forwards';
            } else {
              impactBurst.style.animation = 'impactBurst 0.4s ease-out forwards';
            }
            
            targetSprite.style.animation = flip ? 'targetShakeFlipped 0.5s ease-out forwards' : 'targetShake 0.5s ease-out forwards';
            
            // Animate particles
            const particles = document.querySelectorAll('.phy-particle');
            particles.forEach((particle, index) => {
              // Generate random animation for each particle
              const angle = Math.random() * 360;
              const distance = 30 + Math.random() * 20;
              const duration = 0.3 + Math.random() * 0.3;
              const delay = Math.random() * 0.2;
              
              particle.style.animation = `none`;
              void particle.offsetWidth; // Force reflow
              
              particle.style.animation = `
                phy_particle${index} ${duration}s ${delay}s forwards
              `;
              
              // Add keyframe rule for this specific particle
              const keyframeRule = `
                @keyframes phy_particle${index} {
                  0% { transform: translate(0, 0) scale(0.8); opacity: 0; }
                  30% { transform: translate(${flip ? (distance/3 * Math.cos(angle * Math.PI/180)) : (-distance/3 * Math.cos(angle * Math.PI/180))}px, 
                                            ${-distance/3 * Math.sin(angle * Math.PI/180)}px) scale(1.2); opacity: 0.8; }
                  100% { transform: translate(${flip ? (distance * Math.cos(angle * Math.PI/180)) : (-distance * Math.cos(angle * Math.PI/180))}px, 
                                            ${-distance * Math.sin(angle * Math.PI/180)}px) scale(0.5); opacity: 0; }
                }
              `;
              
              try {
                document.styleSheets[0].insertRule(keyframeRule, 0);
              } catch (e) {
                console.warn("Could not insert animation rule:", e);
              }
            });
          }, 400);
        }, 600);
        
        // 4. Remove the animation container after completion
        setTimeout(() => {
          document.body.removeChild(container);
          if (typeof callback === 'function') {
            callback();
          }
        }, 1800);
      }, 100);
    }

    // Main function for special attack animation (for moves that scale off S.ATK)
    function playSpecialAttackAnimation(attacker, target, moveName, callback) {
      // Create animation container
      const container = document.createElement('div');
      container.className = 'attack-animation-container';
      document.body.appendChild(container);
      
      // Create overlay
      const overlay = document.createElement('div');
      overlay.className = 'attack-overlay';
      container.appendChild(overlay);
      
      // Create digital field
      const digitalField = document.createElement('div');
      digitalField.className = 'attack-digital-field';
      container.appendChild(digitalField);
      
      // Determine if we need to flip the animation (enemy attacking player)
      // If the attacker is an enemy (i.e., not in the player's party), flip = true
      const flip = !gameState.party.some(digimon => digimon.uniqueID === attacker.uniqueID);
      
      // Create sprite representations with positions based on flip parameter
      const attackerSprite = document.createElement('div');
      attackerSprite.className = 'attacker-sprite';
      attackerSprite.style.backgroundImage = `url(${attacker.spriteUrl})`;
      
      const targetSprite = document.createElement('div');
      targetSprite.className = 'target-sprite';
      targetSprite.style.backgroundImage = `url(${target.spriteUrl})`;
      
      if (flip) {
        // Flip positions for enemy attacking player
        attackerSprite.style.left = 'auto';
        attackerSprite.style.right = '20%';
        attackerSprite.style.transform = 'translateY(-50%) scaleX(-1)';
        
        targetSprite.style.right = 'auto';
        targetSprite.style.left = '20%';
        targetSprite.style.transform = 'translateY(-50%)';
      }
      
      container.appendChild(attackerSprite);
      container.appendChild(targetSprite);
      
      // Create attacker aura
      const aura = document.createElement('div');
      aura.className = 'attacker-aura';
      if (flip) {
        aura.style.left = 'auto';
        aura.style.right = '20%';
      }
      container.appendChild(aura);
      
      // Create energy particles with positions based on flip parameter
      for (let i = 0; i < 15; i++) {
        const particle = document.createElement('div');
        particle.className = 'sp-energy-particle';
        
        // Random positions around the attacker
        const offset = 20 + Math.random() * 30;
        const angle = Math.random() * 360;
        
        if (flip) {
          const right = 20 + offset * Math.cos(angle * Math.PI/180) / 100;
          const top = 50 + offset * Math.sin(angle * Math.PI/180) / 100;
          particle.style.right = `${right}%`;
          particle.style.left = 'auto';
          particle.style.top = `${top}%`;
        } else {
          const left = 20 + offset * Math.cos(angle * Math.PI/180) / 100;
          const top = 50 + offset * Math.sin(angle * Math.PI/180) / 100;
          particle.style.left = `${left}%`;
          particle.style.top = `${top}%`;
        }
        
        container.appendChild(particle);
      }
      
      // Create energy beam with position based on flip parameter
      const beam = document.createElement('div');
      beam.className = 'energy-beam';
      const beamPattern = document.createElement('div');
      beamPattern.className = 'beam-pattern';
      beam.appendChild(beamPattern);
      
      if (flip) {
        beam.style.left = 'auto';
        beam.style.right = '25%';
        beam.style.transformOrigin = 'right center';
      }
      
      container.appendChild(beam);
      
      // Create impact explosion with position based on flip parameter
      const explosion = document.createElement('div');
      explosion.className = 'impact-explosion';
      if (flip) {
        explosion.style.right = 'auto';
        explosion.style.left = '20%';
      }
      container.appendChild(explosion);
      
      // Create digital fragments with positions based on flip parameter
      for (let i = 0; i < 12; i++) {
        const fragment = document.createElement('div');
        fragment.className = 'digital-fragment';
        if (flip) {
          fragment.style.right = 'auto';
          fragment.style.left = '20%';
        }
        container.appendChild(fragment);
      }
      
      // Create flash effect
      const flashEffect = document.createElement('div');
      flashEffect.className = 'flash-effect';
      container.appendChild(flashEffect);
      
      // Animation sequence
      setTimeout(() => {
        // 1. Show digital field
        digitalField.style.opacity = '0.5';
        
        // 2. Attacker charges up (aura effect)
        setTimeout(() => {
          aura.style.opacity = '1';
          if (flip) {
            aura.style.animation = 'auraGrowFlipped 0.8s ease-out forwards';
          } else {
            aura.style.animation = 'auraGrow 0.8s ease-out forwards';
          }
          
          // Energy particles converge
          const energyParticles = document.querySelectorAll('.sp-energy-particle');
          energyParticles.forEach((particle, index) => {
            particle.style.opacity = '0.8';
            const delay = Math.random() * 0.5;
            if (flip) {
              particle.style.animation = `particleConvergeFlipped 0.8s ${delay}s ease-in-out forwards`;
            } else {
              particle.style.animation = `particleConverge 0.8s ${delay}s ease-in-out forwards`;
            }
          });
        }, 300);
        
        // 3. Fire energy beam
        setTimeout(() => {
          // Quick flash
          flashEffect.style.animation = 'quickFlash 0.3s ease-out';
          
          // Extend beam
          beam.style.opacity = '1';
          if (flip) {
            beam.style.animation = 'beamExtendFlipped 0.5s ease-out forwards';
          } else {
            beam.style.animation = 'beamExtend 0.5s ease-out forwards';
          }
        }, 1200);
        
        // 4. Impact explosion
        setTimeout(() => {
          // Strong flash on impact
          flashEffect.style.animation = 'strongFlash 0.5s ease-out';
          
          // Grow explosion
          explosion.style.opacity = '1';
          explosion.style.animation = 'explosionGrow 0.6s ease-out forwards';
          
          // Shake target
          targetSprite.style.animation = flip ? 'targetShakeFlipped 0.5s ease-out forwards' : 'targetShake 0.5s ease-out forwards';
          
          // Animate digital fragments
          const fragments = document.querySelectorAll('.digital-fragment');
          fragments.forEach((fragment, index) => {
            // Generate random animation for each fragment
            const angle = Math.random() * 360;
            const distance = 50 + Math.random() * 40;
            const duration = 0.5 + Math.random() * 0.3;
            const delay = Math.random() * 0.2;
            
            fragment.style.animation = `none`;
            void fragment.offsetWidth; // Force reflow
            
            fragment.style.animation = `
              sp_fragment${index} ${duration}s ${delay}s forwards
            `;
            
            // Add keyframe rule for this specific fragment
            const keyframeRule = `
              @keyframes sp_fragment${index} {
                0% { transform: translate(0, -50%) rotate(0deg) scale(0); opacity: 0; }
                20% { transform: translate(0, -50%) rotate(${angle/2}deg) scale(1.2); opacity: 1; }
                100% { transform: translate(${flip ? (distance * Math.cos(angle * Math.PI/180)) : (-distance * Math.cos(angle * Math.PI/180))}px, 
                                          ${-distance * Math.sin(angle * Math.PI/180)}px) 
                                          rotate(${angle * 2}deg) scale(0.5); opacity: 0; }
              }
            `;
            
            try {
              document.styleSheets[0].insertRule(keyframeRule, 0);
            } catch (e) {
              console.warn("Could not insert animation rule:", e);
            }
          });
        }, 1700);
        
        // 5. Remove the animation container after completion
        setTimeout(() => {
          document.body.removeChild(container);
          if (typeof callback === 'function') {
            callback();
          }
        }, 2500);
      }, 100);
    }

    /***************************************************************
      DIGIMON ROGUE-LIKE RPG
      Full implementation of the game according to digimongameprompt.txt
    ***************************************************************/

    /* A. GLOBAL / PERSISTENT GAME STATE */
    let gameState = {
      // Persistent data (saved across runs)
      caughtDigimon: [],    // all Digimon ever caught
      digicrystals: 0,      // meta currency
      permanentUpgrades: {}, // unlocks & upgrades
      digiviceLevels: {
        'Original': 1,
        'D3': 1,
        'D-ARK': 1, // Scanner/D-ARK Digivice
        '???1': 0,
        '???2': 0,
        '???3': 0
      },
      saveSlots: [null, null, null],

      // Run-based data (reset each new run)
      runActive: false,
      roundNumber: 1,
      party: [],
      inventory: {},
      gold: 0,
      activeDigivice: null,
      cardLibrary: [],
      activeEnemy: null,
      nextTamerBattle: 25,
      nextShop: 5,
      captureCount: 0
    };

    // Current variant filter for storage display
    let currentVariantFilter = "All";

    /* B. TYPE EFFECTIVENESS */
    function getTypeEffectiveness(attackType, defenderType) {
      // Normalize case for consistent comparison
      const atk = attackType.toLowerCase();
      const def = defenderType.toLowerCase();
      
      if (atk === "virus" && def.includes("data")) return 2;
      if (atk === "data" && def.includes("vaccine")) return 2;
      if (atk === "vaccine" && def.includes("virus")) return 2;
      if (atk === "virus" && def.includes("vaccine")) return 0.5;
      if (atk === "data" && def.includes("virus")) return 0.5;
      if (atk === "vaccine" && def.includes("data")) return 0.5;
      return 1;
    }

    /* C. TAMER BATTLES & BOSSES */
    const tamerBattles = [
      {
        name: "Tamer Takato",
        digimonTeam: ["Guilmon", "Greymon", "Garurumon", "Togemon", "Kyubimon"]
      },
      {
        name: "Tamer Henry",
        digimonTeam: ["Terriermon", "MetalGreymon", "WereGarurumon", "Lillymon", "Taomon"]
      },
      {
        name: "Tamer Rika",
        digimonTeam: ["Renamon", "WarGreymon", "MetalGarurumon", "Rosemon", "Sakuyamon"]
      }
    ];

    const bossList = [
      { round: 10, name: "Devimon", level: 25 },
      { round: 20, name: "Etemon", level: 35 },
      { round: 30, name: "Myotismon", level: 45 },
      { round: 40, name: "MetalEtemon", level: 55 },
      { round: 50, name: "Piedmon", level: 65 }
    ];

    /* D. DIGIMON CREATION & VARIANT LOGIC */
    // Unique ID counter for Digimon
    let uniqueDigimonCounter = 1000;

    function createDigimon(digiName, level = 1) {
      let base = DigimonDB[digiName];
      if (!base) {
        console.warn("Missing data for", digiName);
        return null;
      }
      
      // Variant logic
      let variant = "Normal";
      let luck = calculateLuck();
      let roll = Math.random() * 1100;
      roll -= (luck * 3); // Luck has stronger effect
      
      // Only spawn variants after round 15
      if (gameState.roundNumber >= 15) {
        if (roll < 1) variant = "Stella";
        else if (roll < 6) variant = "Prisma"; 
        else if (roll < 30) variant = "Chroma";
      }
      
      // Generate unique ID
      let uniqueID = uniqueDigimonCounter++;
      
      // Create Digimon instance with IV-like stats
      let newDigi = {
        uniqueID,
        name: base.name,
        variant,
        stage: base.stage,
        type: base.type,
        level,
        exp: 0,
        expToNext: level * 100,
        baseStats: { ...base.baseStats },
        currentStats: { ...base.baseStats },
        currentHP: base.baseStats.HP,
        moves: [],
        movePP: {}, // Track current PP for each move
        abilities: [...(base.abilities || [])],
        spriteUrl: base.spriteUrl,
        evoData: base.nextEvo,
        originalName: base.name,
        luck: 5 + (variant === "Chroma" ? 10 : 0) + (variant === "Prisma" ? 25 : 0) + (variant === "Stella" ? 50 : 0)
      };
      
      // IV-like random bonus stats (more substantial)
      let ivRange = 8;
      for (let stat in newDigi.baseStats) {
        let bonus = Math.floor(Math.random() * ivRange);
        newDigi.baseStats[stat] += bonus;
        newDigi.currentStats[stat] += bonus;
      }
      
      // Variant stat bonuses
      if (variant === "Chroma") {
        for (let stat in newDigi.baseStats) {
          let bonus = Math.floor(newDigi.baseStats[stat] * 0.1);
          newDigi.baseStats[stat] += bonus;
          newDigi.currentStats[stat] += bonus;
        }
      } else if (variant === "Prisma") {
        for (let stat in newDigi.baseStats) {
          let bonus = Math.floor(newDigi.baseStats[stat] * 0.2);
          newDigi.baseStats[stat] += bonus;
          newDigi.currentStats[stat] += bonus;
        }
      } else if (variant === "Stella") {
        for (let stat in newDigi.baseStats) {
          let bonus = Math.floor(newDigi.baseStats[stat] * 0.3);
          newDigi.baseStats[stat] += bonus;
          newDigi.currentStats[stat] += bonus;
        }
      }
      
      // Populate moves by level
      let ls = base.learnset || [];
      let moveCount = 0;
      ls.forEach(m => {
        if (level >= m.level && moveCount < 4) {
          newDigi.moves.push(m.move);
          // Initialize PP for the move
          let moveData = MoveDB[m.move];
          if (moveData) {
            newDigi.movePP[m.move] = moveData.pp;
          }
          moveCount++;
        }
      });
      
      return newDigi;
    }

    /* E. START / END RUN, SAVE/LOAD */
    function newRun() {
      resetRunState();
      document.getElementById("main-menu").style.display = "none";
      document.getElementById("character-select").style.display = "flex";
      renderStarterDigimon();
      renderDigiviceSelection();
    }

    function resetRunState() {
      gameState.runActive = true;
      gameState.roundNumber = 1;
      gameState.party = [];
      gameState.inventory = {
        "DigiHex": 3,
        "Potion": 3
      };
      gameState.gold = 100;
      gameState.cardLibrary = [];
      gameState.activeEnemy = null;
      gameState.nextTamerBattle = 25;
      gameState.nextShop = 5;
      gameState.captureCount = 0;
      
      // Start with 5 random DE cards
      for (let i = 0; i < 5; i++) {
        let card = getRandomDECard();
        if (card) gameState.cardLibrary.push(card);
      }
    }

    function confirmStarters() {
      let selected = document.querySelectorAll(".digimon-starter-card.selected");
      if (selected.length < 1 || selected.length > 3) {
        alert("Select 1-3 starters!");
        return;
      }
      
      if (!gameState.activeDigivice) {
        alert("Select a Digivice!");
        return;
      }
      
      gameState.party = [];
      selected.forEach(card => {
        let name = card.getAttribute("data-name");
        let digi = createDigimon(name, 5);
        gameState.party.push(digi);
      });
      
      document.getElementById("character-select").style.display = "none";
      randomEncounter();
    }

    function backToMainMenu() {
      document.getElementById("character-select").style.display = "none";
      document.getElementById("main-menu").style.display = "flex";
    }

    function endRun() {
      let crystals = Math.floor(gameState.roundNumber * 1.5);
      gameState.digicrystals += crystals;
      
      document.getElementById("battle-screen").style.display = "none";
      document.getElementById("end-run-panel").style.display = "flex";
      
      // Update summary
      document.getElementById("summary-rounds").innerText = gameState.roundNumber;
      document.getElementById("summary-captures").innerText = gameState.captureCount;
      document.getElementById("summary-gold").innerText = gameState.gold;
      document.getElementById("summary-crystals").innerText = crystals;
      
      gameState.runActive = false;
      saveGlobalState();
    }

    function returnToMainMenu() {
      document.getElementById("end-run-panel").style.display = "none";
      document.getElementById("main-menu").style.display = "flex";
    }

    function saveRun(slot = 0) {
      let data = JSON.stringify(gameState);
      gameState.saveSlots[slot] = data;
      localStorage.setItem(`digimon_run_slot_${slot}`, data);
      alert("Run saved to slot " + slot + "!");
    }

    function loadRun() {
      let slotOptions = "";
      
      for (let i = 0; i < 3; i++) {
        let data = localStorage.getItem(`digimon_run_slot_${i}`);
        if (data) {
          let save = JSON.parse(data);
          slotOptions += `<button class="digimon-btn" onclick="loadSlot(${i})">Slot ${i+1} (Round ${save.roundNumber})</button>`;
        }
      }
      
      if (slotOptions === "") {
        alert("No saved runs found!");
        return;
      }
      
      // Create a modal for slot selection
      let modal = document.createElement("div");
      modal.style.position = "fixed";
      modal.style.top = "0";
      modal.style.left = "0";
      modal.style.width = "100%";
      modal.style.height = "100%";
      modal.style.backgroundColor = "rgba(0,0,0,0.8)";
      modal.style.display = "flex";
      modal.style.justifyContent = "center";
      modal.style.alignItems = "center";
      modal.style.zIndex = "1000";
      
      let content = document.createElement("div");
      content.style.backgroundColor = "#1c2541";
      content.style.padding = "20px";
      content.style.borderRadius = "8px";
      content.style.maxWidth = "300px";
      content.style.textAlign = "center";
      
      content.innerHTML = `
        <h3 style="margin-bottom:15px">Select Save Slot</h3>
        ${slotOptions}
        <button class="digimon-btn" style="margin-top:15px" onclick="document.body.removeChild(this.parentNode.parentNode)">Cancel</button>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
    }

    function loadSlot(slot) {
      let data = localStorage.getItem(`digimon_run_slot_${slot}`);
      if (data) {
        gameState = JSON.parse(data);
        document.getElementById("main-menu").style.display = "none";
        
        if (gameState.runActive) {
          document.getElementById("battle-screen").style.display = "flex";
          updateBattleUI();
        } else {
          proceedNextRound();
        }
        
        // Remove modal if it exists
        let modal = document.querySelector("div[style*='z-index: 1000']");
        if (modal) document.body.removeChild(modal);
      }
    }

        // Global state save/load
    function saveGlobalState() {
      let data = JSON.stringify({
        caughtDigimon: gameState.caughtDigimon,
        digicrystals: gameState.digicrystals,
        permanentUpgrades: gameState.permanentUpgrades,
        digiviceLevels: gameState.digiviceLevels,
        saveSlots: gameState.saveSlots
      });
      localStorage.setItem("digimon_global_state", data);
      
      // Also save individual save slots to localStorage
      gameState.saveSlots.forEach((slotData, index) => {
        if (slotData) {
          localStorage.setItem(`digimon_run_slot_${index}`, slotData);
        }
      });
    }

    function loadGlobalStateOnStartup() {
      let data = localStorage.getItem("digimon_global_state");
      if (data) {
        let state = JSON.parse(data);
        gameState.caughtDigimon = state.caughtDigimon || [];
        gameState.digicrystals = state.digicrystals || 0;
        gameState.permanentUpgrades = state.permanentUpgrades || {};
        gameState.digiviceLevels = state.digiviceLevels || {
          'Original': 1,
          'D3': 1,
          'D-ARK': 1,
          '???1': 0,
          '???2': 0,
          '???3': 0
        };
        gameState.saveSlots = state.saveSlots || [null, null, null];
              }
      }

    /* F. BATTLE & PROGRESSION */
    let activePlayerDigimonIndex = 0;

    function startBattle(enemyName) {
      let enemy = createDigimon(enemyName, calcEnemyLevel());
      gameState.activeEnemy = enemy;
      document.getElementById("battle-screen").style.display = "flex";
      
      // Initialize battle data tracking for active Digimon
      let player = gameState.party[activePlayerDigimonIndex];
      if (player) {
        player.battleData = {
          enemy: enemy,
          damageTaken: 0,
          maxDamagePercent: 0,
          win: false
        };
        applyAbilities(player, "battleStart");
      }
      
      applyAbilities(enemy, "battleStart");
      
      updateBattleUI();
      logToBattle(`A wild ${enemy.name} (ID #${enemy.uniqueID}) appears!`);
    }

    function updateBattleUI() {
      let player = gameState.party[activePlayerDigimonIndex];
      let enemy = gameState.activeEnemy;
      
      // Update gold and round display
      document.getElementById("gold-display").textContent = gameState.gold;
      document.getElementById("round-display").textContent = gameState.roundNumber;
      
      if (!player || !enemy) return;
      
      // Update player info
      document.getElementById("player-digimon-name").textContent = player.name;
      document.getElementById("player-digimon-type").textContent = player.type;
      document.getElementById("player-digimon-type").className = `digimon-type type-${player.type.toLowerCase()}`;
      document.getElementById("player-hp-text").textContent = `${player.currentHP}/${player.currentStats.HP}`;
      document.getElementById("player-hp-fill").style.width = `${(player.currentHP / player.currentStats.HP) * 100}%`;
      document.getElementById("player-level").textContent = player.level;
      document.getElementById("player-exp-fill").style.width = `${(player.exp / player.expToNext) * 100}%`;
      document.getElementById("player-digimon-sprite").style.backgroundImage = `url(${player.spriteUrl})`;
      
      // Update enemy info
      document.getElementById("enemy-digimon-name").textContent = enemy.name;
      document.getElementById("enemy-digimon-type").textContent = enemy.type;
      document.getElementById("enemy-digimon-type").className = `digimon-type type-${enemy.type.toLowerCase()}`;
      document.getElementById("enemy-hp-text").textContent = `${enemy.currentHP}/${enemy.currentStats.HP}`;
      document.getElementById("enemy-hp-fill").style.width = `${(enemy.currentHP / enemy.currentStats.HP) * 100}%`;
      document.getElementById("enemy-level").textContent = enemy.level;
      document.getElementById("enemy-digimon-sprite").style.backgroundImage = `url(${enemy.spriteUrl})`;
    }

    function calcEnemyLevel() {
      // Progressive difficulty
      return Math.max(5, Math.floor(5 + gameState.roundNumber * 0.8));
    }

    function randomEncounter() {
      // Filter for appropriate Digimon based on round
      let stage = "Rookie";
      if (gameState.roundNumber > 30) stage = "Ultimate";
      else if (gameState.roundNumber > 15) stage = "Champion";
      
      let pool = Object.keys(DigimonDB).filter(k => DigimonDB[k].stage === stage);
      if (pool.length === 0) pool = Object.keys(DigimonDB).filter(k => DigimonDB[k].stage === "Rookie");
      
      let rng = Math.floor(Math.random() * pool.length);
      let name = pool[rng];
      startBattle(name);
    }

    function selectMoveAction() {
      document.getElementById("move-selection-overlay").style.display = "flex";
      renderMoveSelection();
    }

    function closeMoveSelection() {
      document.getElementById("move-selection-overlay").style.display = "none";
    }

    function renderMoveSelection() {
      let container = document.getElementById("move-selection-list");
      container.innerHTML = "";
      
      let active = gameState.party[activePlayerDigimonIndex];
      if (!active) return;
      
      active.moves.forEach(moveName => {
        let move = MoveDB[moveName];
        if (!move) return;
        
        let typeClass = `type-${move.type.toLowerCase()}`;
        let currentPP = active.movePP[moveName] || 0;
        let maxPP = move.pp;
        
        let moveElement = document.createElement("div");
        moveElement.className = "move-btn";
        
        // Disable if no PP remaining
        if (currentPP <= 0) {
          moveElement.style.opacity = "0.5";
          moveElement.style.cursor = "not-allowed";
        } else {
          moveElement.onclick = () => useMove(moveName);
        }
        
        moveElement.innerHTML = `
          <div class="move-header">
            <span class="move-name">${moveName}</span>
            <span class="move-pp">${currentPP}/${maxPP} PP</span>
          </div>
          <span class="move-type ${typeClass}">${move.type}</span>
          <p class="move-description">${move.description || ""}</p>
        `;
        
        container.appendChild(moveElement);
      });
    }

    function trackMoveTypeUsage(digimon, moveType) {
      if (!digimon.moveTypeUses) digimon.moveTypeUses = {};
      if (!digimon.moveTypeUses[moveType]) digimon.moveTypeUses[moveType] = 0;
      digimon.moveTypeUses[moveType]++;
    }

    // Helper function to continue processing the attack after animation completes
    function continueAttackProcessing(user, target, move, moveName) {
      // Calculate damage
      let atk = (move.scale === "ATK") ? user.currentStats.ATK : user.currentStats.SATK;
      let def = (move.scale === "ATK") ? target.currentStats.DEF : target.currentStats.SDEF;
      let power = move.power || 0;
      let typeEffect = getTypeEffectiveness(move.type, target.type);
      let stab = (user.type.includes(move.type)) ? 1.5 : 1;
      
      let damage = 0;
      if (power > 0) {
        damage = Math.floor((((2 * user.level / 5 + 2) * atk * power / def) / 50 + 2) * typeEffect * stab);
        
        // Random factor (85-100%)
        damage = Math.floor(damage * (0.85 + Math.random() * 0.15));
      }
      
      if (typeEffect > 1) {
        logToBattle("It's super effective!");
      } else if (typeEffect < 1 && typeEffect > 0) {
        logToBattle("It's not very effective...");
      } else if (typeEffect === 0) {
        logToBattle("It has no effect!");
        damage = 0;
      }
      
      if (damage > 0) {
        target.currentHP = Math.max(0, target.currentHP - damage);
        logToBattle(`Dealt ${damage} damage!`);
        
        // Track max damage percent for evolution requirements
        let damagePercent = (damage / target.currentStats.HP) * 100;
        user.battleData = user.battleData || {};
        user.battleData.maxDamagePercent = Math.max(damagePercent, user.battleData.maxDamagePercent || 0);
      }
      
      // Apply move effects
      applyMoveEffect(user, target, move.effect);
      
      // Check if battle is over
      if (target.currentHP <= 0) {
        logToBattle(`${target.name} was defeated!`);
        
        // Update battle data for evolution tracking
        user.battleData = user.battleData || {};
        user.battleData.win = true;
        user.battleData.enemy = {type: target.type, name: target.name};
        
        awardExp(user, target);
        endBattleWin();
      } else {
        // Enemy turn
        enemyAction();
      }
      
      updateBattleUI();
    }

    // Make sure to integrate these tracking functions in the battle system
    function useMove(moveName) {
      closeMoveSelection();
      
      let user = gameState.party[activePlayerDigimonIndex];
      let target = gameState.activeEnemy;
      
      if (!target || !user) return;
      
      let move = MoveDB[moveName];
      if (!move) {
        logToBattle("Move data not found!");
        return;
      }
      
      // Check PP
      let currentPP = user.movePP[moveName] || 0;
      if (currentPP <= 0) {
        logToBattle(`${moveName} has no PP left!`);
        return;
      }
      
      // Deplete PP
      user.movePP[moveName] = Math.max(0, currentPP - 1);
      
      // Track move type usage for evolution requirements
      if (move.type) {
        trackMoveTypeUsage(user, move.type);
      }
      
      // Log the move use first
      logToBattle(`${user.name} (ID #${user.uniqueID}) used ${moveName}!`);
      
      // Determine which animation to use based on the move's scale
      if (move.power > 0) {
        if (move.scale === "ATK") {
          // Physical attack (scales off ATK)
          playPhysicalAttackAnimation(user, target, moveName, () => {
            // Continue battle processing after animation completes
            continueAttackProcessing(user, target, move, moveName);
          });
        } else if (move.scale === "SATK") {
          // Special attack (scales off S.ATK)
          playSpecialAttackAnimation(user, target, moveName, () => {
            // Continue battle processing after animation completes
            continueAttackProcessing(user, target, move, moveName);
          });
        } else {
          // No animation for other scale types, or we could add more specific animations later
          continueAttackProcessing(user, target, move, moveName);
        }
      } else {
        // Status move with no animation, or we could add a status animation later
        continueAttackProcessing(user, target, move, moveName);
      }
    }

    function applyMoveEffect(user, target, effect) {
      if (!effect) return;
      
      // Status effects
      if (effect.includes("glitch")) {
        let chance = parseInt(effect.replace("glitch", "")) || 10;
        if (Math.random() * 100 < chance) {
          target.status = "glitch";
          logToBattle(`${target.name} has been glitched!`);
        }
      }
      
      if (effect.includes("flinch")) {
        let chance = parseInt(effect.replace("flinch", "")) || 10;
        if (Math.random() * 100 < chance) {
          target.flinched = true;
          logToBattle(`${target.name} flinched!`);
        }
      }
      
      // Healing
      if (effect.includes("heal")) {
        let percent = parseInt(effect.replace("heal", "")) || 20;
        let amount = Math.floor(user.currentStats.HP * (percent / 100));
        user.currentHP = Math.min(user.currentStats.HP, user.currentHP + amount);
        logToBattle(`${user.name} healed ${amount} HP!`);
      }
      
      // Recoil damage
      if (effect.includes("recoil")) {
        let percent = parseInt(effect.replace("recoil", "")) || 25;
        let amount = Math.floor(user.currentStats.HP * (percent / 100));
        user.currentHP = Math.max(1, user.currentHP - amount);
        logToBattle(`${user.name} took ${amount} recoil damage!`);
      }
      
      // Stat changes
      if (effect.includes("self") && effect.includes("ATKup")) {
        user.currentStats.ATK = Math.floor(user.currentStats.ATK * 1.2);
        logToBattle(`${user.name}'s Attack rose!`);
      }
      
      if (effect.includes("self") && effect.includes("SATKup")) {
        user.currentStats.SATK = Math.floor(user.currentStats.SATK * 1.2);
        logToBattle(`${user.name}'s Special Attack rose!`);
      }
      
      if (effect.includes("self") && effect.includes("DEFup")) {
        user.currentStats.DEF = Math.floor(user.currentStats.DEF * 1.2);
        logToBattle(`${user.name}'s Defense rose!`);
      }
      
      if (effect.includes("self") && effect.includes("SDEFup")) {
        user.currentStats.SDEF = Math.floor(user.currentStats.SDEF * 1.2);
        logToBattle(`${user.name}'s Special Defense rose!`);
      }
      
      // Clear status
      if (effect.includes("clearStatuses")) {
        user.status = null;
        logToBattle(`${user.name}'s status effects were cleared!`);
      }

      // Additional effects
      if (effect.includes("critUp")) {
        // This move has increased critical hit chance (handled in damage calculation)
        // For now, just log it
        logToBattle("Critical hit chance increased!");
      }

      if (effect.includes("priority")) {
        // This move goes first (would need turn order system to fully implement)
        logToBattle("The attack struck with lightning speed!");
      }

      if (effect.includes("confusion")) {
        let chance = parseInt(effect.replace("confusion", "")) || 30;
        if (Math.random() * 100 < chance) {
          target.status = "confused";
          logToBattle(`${target.name} became confused!`);
        }
      }

      if (effect.includes("scan")) {
        // Reveals enemy information (could expand this)
        logToBattle(`Scanning ${target.name}... Data acquired!`);
      }

      if (effect.includes("stealBuffs")) {
        // Steals stat boosts from target (simplified)
        logToBattle(`${user.name} absorbed ${target.name}'s power!`);
      }

      // Damage reduction effects
      if (effect.includes("dmgReduce50_3")) {
        user.damageReduction = { value: 0.5, turns: 3 };
        logToBattle(`${user.name} will take reduced damage for 3 turns!`);
      }

      // Stat up effects with chances
      if (effect.includes("satkUp15")) {
        if (Math.random() * 100 < 15) {
          user.currentStats.SATK = Math.floor(user.currentStats.SATK * 1.2);
          logToBattle(`${user.name}'s Special Attack rose!`);
        }
      }

      if (effect.includes("defDown15")) {
        if (Math.random() * 100 < 15) {
          target.currentStats.DEF = Math.floor(target.currentStats.DEF * 0.8);
          logToBattle(`${target.name}'s Defense fell!`);
        }
      }

      if (effect.includes("randomStatDown2_20")) {
        if (Math.random() * 100 < 20) {
          let stats = ["ATK", "DEF", "SATK", "SDEF", "SPD"];
          for (let i = 0; i < 2; i++) {
            let randomStat = stats[Math.floor(Math.random() * stats.length)];
            target.currentStats[randomStat] = Math.floor(target.currentStats[randomStat] * 0.85);
            logToBattle(`${target.name}'s ${randomStat} fell!`);
          }
        }
      }

      if (effect.includes("hpCost20")) {
        let cost = Math.floor(user.currentStats.HP * 0.2);
        user.currentHP = Math.max(1, user.currentHP - cost);
        logToBattle(`${user.name} paid ${cost} HP to use this move!`);
      }

      if (effect.includes("miss50")) {
        // This would be handled in damage calculation, but we'll log it here
        logToBattle("The move has a high chance to miss!");
      }

      if (effect.includes("doubleAttack50")) {
        if (Math.random() * 100 < 50) {
          logToBattle(`${user.name} will attack again!`);
          user.doubleAttack = true;
        }
      }

      // New status effects
      if (effect.includes("freeze")) {
        let chance = parseInt(effect.replace("freeze", "")) || 30;
        if (Math.random() * 100 < chance) {
          target.status = "frozen";
          logToBattle(`${target.name} was frozen solid!`);
        }
      }

      if (effect.includes("burn")) {
        let chance = parseInt(effect.replace("burn", "")) || 30;
        if (Math.random() * 100 < chance) {
          target.status = "burned";
          logToBattle(`${target.name} was burned!`);
        }
      }

      if (effect.includes("poison")) {
        let chance = parseInt(effect.replace("poison", "")) || 30;
        if (Math.random() * 100 < chance) {
          target.status = "poisoned";
          logToBattle(`${target.name} was poisoned!`);
        }
      }

      if (effect.includes("paralysis")) {
        let chance = parseInt(effect.replace("paralysis", "")) || 30;
        if (Math.random() * 100 < chance) {
          target.status = "paralyzed";
          logToBattle(`${target.name} was paralyzed!`);
        }
      }

      if (effect.includes("sleep")) {
        let chance = parseInt(effect.replace("sleep", "")) || 30;
        if (Math.random() * 100 < chance) {
          target.status = "asleep";
          logToBattle(`${target.name} fell asleep!`);
        }
      }

      // Stat modifications with stages
      if (effect.includes("selfDEFup2")) {
        user.currentStats.DEF = Math.floor(user.currentStats.DEF * 1.4);
        logToBattle(`${user.name}'s Defense rose sharply!`);
      }

      if (effect.includes("selfAtkUp2")) {
        user.currentStats.ATK = Math.floor(user.currentStats.ATK * 1.4);
        logToBattle(`${user.name}'s Attack rose sharply!`);
      }

      if (effect.includes("allStatsUp1_30")) {
        if (Math.random() * 100 < 30) {
          for (let stat of ["ATK", "DEF", "SATK", "SDEF", "SPD"]) {
            user.currentStats[stat] = Math.floor(user.currentStats[stat] * 1.2);
          }
          logToBattle(`All of ${user.name}'s stats rose!`);
        }
      }

      if (effect.includes("allStatsUp2")) {
        for (let stat of ["ATK", "DEF", "SATK", "SDEF", "SPD"]) {
          user.currentStats[stat] = Math.floor(user.currentStats[stat] * 1.4);
        }
        logToBattle(`All of ${user.name}'s stats rose sharply!`);
      }

      // Advanced healing effects
      if (effect.includes("fullHeal")) {
        user.currentHP = user.currentStats.HP;
        user.status = null;
        logToBattle(`${user.name} was fully healed!`);
      }

      if (effect.includes("heal50")) {
        let amount = Math.floor(user.currentStats.HP * 0.5);
        user.currentHP = Math.min(user.currentStats.HP, user.currentHP + amount);
        logToBattle(`${user.name} healed ${amount} HP!`);
      }

      // Multiple hit moves
      if (effect.includes("multiHit")) {
        // This would be handled in damage calculation
        logToBattle("The move hits multiple times!");
      }

      // Special type interactions
      if (effect.includes("exorcism") && target.type.includes("Virus")) {
        logToBattle("It's super effective against Virus types!");
      }

      if (effect.includes("dragonSlayer")) {
        // Would need dragon typing system
        logToBattle("Dragon-slaying power activated!");
      }
    }

    function enemyAction() {
      let enemy = gameState.activeEnemy;
      let player = gameState.party[activePlayerDigimonIndex];
      
      if (!enemy || !player) return;
      
      // Skip turn if flinched
      if (enemy.flinched) {
        enemy.flinched = false;
        logToBattle(`${enemy.name} is flinched and couldn't move!`);
        return;
      }
      
      // Choose a move
      let moveOptions = enemy.moves.length > 0 ? enemy.moves : ["Tackle"];
      let moveChoice = moveOptions[Math.floor(Math.random() * moveOptions.length)];
      let move = MoveDB[moveChoice] || MoveDB["Tackle"];
      
      logToBattle(`${enemy.name} used ${moveChoice}!`);
      
      // Determine which animation to use based on the move's scale
      if (move.power > 0) {
        if (move.scale === "ATK") {
          // Physical attack (scales off ATK)
          playPhysicalAttackAnimation(enemy, player, moveChoice, () => {
            // Continue battle processing after animation completes
            continueEnemyAttackProcessing(enemy, player, move, moveChoice);
          });
        } else if (move.scale === "SATK") {
          // Special attack (scales off S.ATK)
          playSpecialAttackAnimation(enemy, player, moveChoice, () => {
            // Continue battle processing after animation completes
            continueEnemyAttackProcessing(enemy, player, move, moveChoice);
          });
        } else {
          // No animation for other scale types
          continueEnemyAttackProcessing(enemy, player, move, moveChoice);
        }
      } else {
        // Status move with no animation
        continueEnemyAttackProcessing(enemy, player, move, moveChoice);
      }
    }

    function continueEnemyAttackProcessing(enemy, player, move, moveChoice) {
      // Calculate damage
      let atk = (move.scale === "ATK") ? enemy.currentStats.ATK : enemy.currentStats.SATK;
      let def = (move.scale === "ATK") ? player.currentStats.DEF : player.currentStats.SDEF;
      let power = move.power || 0;
      let typeEffect = getTypeEffectiveness(move.type, player.type);
      let stab = (enemy.type.includes(move.type)) ? 1.5 : 1;
      
      let damage = 0;
      if (power > 0) {
        damage = Math.floor((((2 * enemy.level / 5 + 2) * atk * power / def) / 50 + 2) * typeEffect * stab);
        
        // Random factor (85-100%)
        damage = Math.floor(damage * (0.85 + Math.random() * 0.15));
      }
      
      if (typeEffect > 1) {
        logToBattle("It's super effective!");
      } else if (typeEffect < 1 && typeEffect > 0) {
        logToBattle("It's not very effective...");
      } else if (typeEffect === 0) {
        logToBattle("It has no effect!");
        damage = 0;
      }
      
      if (damage > 0) {
        player.currentHP = Math.max(0, player.currentHP - damage);
        logToBattle(`${player.name} took ${damage} damage!`);
        
        // Track damage taken for evolution requirements
        if (player.battleData) {
          player.battleData.damageTaken += damage;
          let damagePercent = (damage / player.currentStats.HP) * 100;
          if (damagePercent > player.battleData.maxDamagePercent) {
            player.battleData.maxDamagePercent = damagePercent;
          }
        }
      }
      
      // Apply move effects
      applyMoveEffect(enemy, player, move.effect);
      
      // Check if player Digimon fainted
      if (player.currentHP <= 0) {
        logToBattle(`${player.name} (ID #${player.uniqueID}) was knocked out!`);
        
        // Remove fainted Digimon from party
        gameState.party.splice(activePlayerDigimonIndex, 1);
        
        // Check if all party Digimon are fainted
        if (gameState.party.length === 0) {
          endBattleLose();
        } else {
          // Reset to first party member
          activePlayerDigimonIndex = 0;
          updateBattleUI();
          logToBattle(`${gameState.party[0].name} (ID #${gameState.party[0].uniqueID}) was sent out!`);
        }
      }
      
      updateBattleUI();
    }

    function awardExp(winner, defeated) {
      let baseExp = defeated.level * 10;
      let exp = Math.floor(baseExp * (1 + (defeated.stage === "Champion" ? 0.5 : 0) + (defeated.stage === "Ultimate" ? 1.0 : 0) + (defeated.stage === "Mega" ? 2.0 : 0)));
      
      // Apply Growth ability for bonus EXP
      let expMultiplier = applyAbilities(winner, "expGain") || 1;
      exp = Math.floor(exp * expMultiplier);
      
      winner.exp += exp;
      logToBattle(`${winner.name} gained ${exp} experience!`);
      
      // Check for level up
      if (winner.exp >= winner.expToNext) {
        levelUp(winner);
      }
      
      updateBattleUI();
    }

    function levelUp(digimon) {
      digimon.level++;
      digimon.exp = 0;
      digimon.expToNext = digimon.level * 100;
      
      // Increase stats
      for (let stat in digimon.baseStats) {
        let increase = Math.floor(digimon.baseStats[stat] * 0.05) + 1;
        digimon.baseStats[stat] += increase;
        digimon.currentStats[stat] += increase;
      }
      
      // Restore HP and PP
      digimon.currentHP = digimon.currentStats.HP;
      restoreAllPP(digimon);
      
      logToBattle(`${digimon.name} grew to level ${digimon.level}!`);
      logToBattle(`All PP restored!`);
      
      // Apply abilities that trigger on level up
      applyAbilities(digimon, "levelUp");
      
      // Check for evolution
      checkEvolution(digimon);
      
      // Check for new moves
      checkNewMoves(digimon);
    }

    function checkNewMoves(digimon) {
      if (!digimon || !DigimonDB[digimon.originalName || digimon.name]) return;
      
      let baseData = DigimonDB[digimon.originalName || digimon.name];
      if (!baseData.learnset) return;
      
      // Check for moves that can be learned at current level
      let learnableMoves = baseData.learnset.filter(moveEntry => 
        moveEntry.level === digimon.level && 
        !digimon.moves.includes(moveEntry.move)
      );
      
      learnableMoves.forEach(moveEntry => {
        if (digimon.moves.length < 4) {
          // Add move directly if there's space
          digimon.moves.push(moveEntry.move);
          // Initialize PP for new move
          let moveData = MoveDB[moveEntry.move];
          if (moveData) {
            digimon.movePP[moveEntry.move] = moveData.pp;
          }
          logToBattle(`${digimon.name} learned ${moveEntry.move}!`);
        } else {
          // Open move selection overlay if party is full
          openMoveLearnOverlay(digimon, moveEntry.move);
        }
      });
    }

    function checkEvolution(digimon) {
      if (!digimon.evoData) return;
      
      // Simple level-based evolution
      if (digimon.evoData.level && digimon.level >= digimon.evoData.level) {
        let newDigimon = DigimonDB[digimon.evoData.target];
        if (newDigimon) {
          evolveDigimon(digimon, digimon.evoData.target);
        }
      }
      
      // Branching evolutions
      if (digimon.evoData.branches) {
        openEvolutionOptions(digimon);
      }
    }

    function openEvolutionOptions(digimon) {
      // Create a modal for evolution selection
      let modal = document.createElement("div");
      modal.style.position = "fixed";
      modal.style.top = "0";
      modal.style.left = "0";
      modal.style.width = "100%";
      modal.style.height = "100%";
      modal.style.backgroundColor = "rgba(0,0,0,0.8)";
      modal.style.display = "flex";
      modal.style.justifyContent = "center";
      modal.style.alignItems = "center";
      modal.style.zIndex = "1000";
      
      let content = document.createElement("div");
      content.style.backgroundColor = "#1c2541";
      content.style.padding = "20px";
      content.style.borderRadius = "8px";
      content.style.maxWidth = "600px";
      content.style.width = "90%";
      content.style.maxHeight = "80vh";
      content.style.overflow = "auto";
      content.style.textAlign = "center";
      
      content.innerHTML = `
        <h2 style="color:#ff8c00;margin-bottom:20px;">Evolution Options for ${digimon.name}</h2>
        <p>Select an evolution path:</p>
        <div id="evolution-options" style="display:flex;flex-wrap:wrap;justify-content:center;margin:20px 0;"></div>
        <button class="digimon-btn" style="margin-top:15px" onclick="document.body.removeChild(this.parentNode.parentNode)">Cancel</button>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // Populate evolution options
      let optionsContainer = content.querySelector("#evolution-options");
      
      if (!digimon.evoData.branches) return;
      
      digimon.evoData.branches.forEach(branch => {
        let targetDigimon = DigimonDB[branch.target];
        if (!targetDigimon) return;
        
        // Check if this evolution is available based on requirements
        let available = checkEvolutionRequirements(digimon, branch);
        let requirementsMet = available.met;
        let requirementsText = available.text;
        
        let evoOption = document.createElement("div");
        evoOption.className = "evolution-option";
        evoOption.style.width = "170px";
        evoOption.style.margin = "10px";
        evoOption.style.padding = "15px";
        evoOption.style.borderRadius = "8px";
        evoOption.style.backgroundColor = requirementsMet ? "rgba(40, 60, 100, 0.8)" : "rgba(60, 60, 60, 0.5)";
        evoOption.style.border = requirementsMet ? "2px solid #4a90e2" : "2px solid #666";
        evoOption.style.cursor = requirementsMet ? "pointer" : "not-allowed";
        evoOption.style.transition = "all 0.3s ease";
        
        if (requirementsMet) {
          evoOption.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.3)";
          evoOption.onmouseover = function() {
            this.style.transform = "translateY(-5px)";
            this.style.boxShadow = "0 8px 16px rgba(0, 0, 0, 0.5)";
          };
          evoOption.onmouseout = function() {
            this.style.transform = "translateY(0)";
            this.style.boxShadow = "0 4px 8px rgba(0, 0, 0, 0.3)";
          };
          evoOption.onclick = function() {
            document.body.removeChild(modal);
            evolveDigimon(digimon, branch.target);
          };
        }
        
        let imgUrl = targetDigimon.spriteUrl || "";
        
        evoOption.innerHTML = `
          <div style="background-image:url('${imgUrl}');width:80px;height:80px;background-size:contain;background-position:center;background-repeat:no-repeat;margin:0 auto 10px;"></div>
          <div style="font-weight:bold;color:#fff;margin-bottom:5px;">${targetDigimon.name}</div>
          <div style="font-size:0.8em;color:#4a90e2;margin-bottom:5px;">${targetDigimon.type} / ${targetDigimon.stage}</div>
          <div style="font-size:0.8em;color:${requirementsMet ? '#7ed321' : '#d0021b'};margin-top:10px;">${requirementsText}</div>
        `;
        
        optionsContainer.appendChild(evoOption);
      });
    }

    function checkEvolutionRequirements(digimon, branch) {
      let requirements = [];
      let met = true;
      
      // Check level requirement
      if (branch.level) {
        let levelMet = digimon.level >= branch.level;
        requirements.push(`Level ${branch.level}: ${levelMet ? '✓' : '✗'}`);
        if (!levelMet) met = false;
      }
      
      // Check item requirement
      if (branch.item) {
        let itemMet = gameState.inventory[branch.item] && gameState.inventory[branch.item] > 0;
        requirements.push(`${branch.item}: ${itemMet ? '✓' : '✗'}`);
        if (!itemMet) met = false;
      }
      
      // Check battle wins requirement
      if (branch.wins) {
        // Assuming digimon has a wins counter
        let wins = digimon.battleWins || 0;
        let winsMet = wins >= branch.wins;
        requirements.push(`${branch.wins} Wins: ${winsMet ? '✓' : '✗'}`);
        if (!winsMet) met = false;
      }
      
      // Check defeated types requirement
      if (branch.defeatType) {
        let defeated = digimon.defeatedTypes && digimon.defeatedTypes[branch.defeatType] || 0;
        let defeatMet = defeated >= (branch.defeatCount || 5);
        requirements.push(`Defeat ${branch.defeatCount || 5} ${branch.defeatType}: ${defeatMet ? '✓' : '✗'}`);
        if (!defeatMet) met = false;
      }
      
      // Check HP loss requirement
      if (branch.hpLossPercent) {
        let hpLossMet = digimon.maxHpLossPercent && digimon.maxHpLossPercent >= branch.hpLossPercent;
        requirements.push(`Lost ${branch.hpLossPercent}% HP in battle: ${hpLossMet ? '✓' : '✗'}`);
        if (!hpLossMet) met = false;
      }
      
      // Check move usage requirement
      if (branch.moveType && branch.moveUseCount) {
        let moveUses = digimon.moveTypeUses && digimon.moveTypeUses[branch.moveType] || 0;
        let moveUseMet = moveUses >= branch.moveUseCount;
        requirements.push(`Use ${branch.moveType} moves ${branch.moveUseCount} times: ${moveUseMet ? '✓' : '✗'}`);
        if (!moveUseMet) met = false;
      }
      
      // Check perfect battle requirement
      if (branch.perfectBattle) {
        let perfectBattles = digimon.perfectBattles || 0;
        let perfectMet = perfectBattles >= 1;
        requirements.push(`Win without taking damage: ${perfectMet ? '✓' : '✗'}`);
        if (!perfectMet) met = false;
      }
      
      return {
        met: met,
        text: requirements.join('<br>')
      };
    }

    function evolveDigimon(digimon, targetName) {
      let newForm = DigimonDB[targetName];
      if (!newForm) return;
      
      // Save important properties
      let oldID = digimon.uniqueID;
      let oldLevel = digimon.level;
      let oldExp = digimon.exp;
      let oldExpToNext = digimon.expToNext;
      let oldName = digimon.name;
      
      // Apply evolution
      digimon.name = newForm.name;
      digimon.stage = newForm.stage;
      digimon.type = newForm.type;
      digimon.spriteUrl = newForm.spriteUrl;
      digimon.evoData = newForm.nextEvo;
      digimon.abilities = [...(newForm.abilities || [])];
      
      // Boost stats based on new form
      for (let stat in newForm.baseStats) {
        // Calculate stat difference and apply it
        let increase = newForm.baseStats[stat] - digimon.baseStats[stat];
        digimon.baseStats[stat] += increase;
        digimon.currentStats[stat] += increase;
      }
      
      // Restore HP to full
      digimon.currentHP = digimon.currentStats.HP;
      
      // Keep original ID and level
      digimon.uniqueID = oldID;
      digimon.level = oldLevel;
      digimon.exp = oldExp;
      digimon.expToNext = oldExpToNext;
      
      logToBattle(`${oldName} has evolved to ${digimon.name}!`);
      
      // Play evolution animation
      playEvolutionAnimation(digimon, newForm);
      
      // Use up the required item if applicable
      if (digimon.evoData && digimon.evoData.item && gameState.inventory[digimon.evoData.item]) {
        gameState.inventory[digimon.evoData.item]--;
        logToBattle(`Used 1 ${digimon.evoData.item} for evolution!`);
      }
      
      updateBattleUI();
    }

    function playEvolutionAnimation(digimon, newForm) {
      // Create a modal for the evolution animation
      let modal = document.createElement("div");
      modal.style.position = "fixed";
      modal.style.top = "0";
      modal.style.left = "0";
      modal.style.width = "100%";
      modal.style.height = "100%";
      modal.style.backgroundColor = "rgba(0,0,0,0.8)";
      modal.style.display = "flex";
      modal.style.justifyContent = "center";
      modal.style.alignItems = "center";
      modal.style.zIndex = "1000";
      
      // Create animation container
      let container = document.createElement("div");
      container.style.position = "relative";
      container.style.width = "300px";
      container.style.height = "300px";
      container.style.overflow = "hidden";
      
      // Old form sprite
      let oldSprite = document.createElement("div");
      oldSprite.style.position = "absolute";
      oldSprite.style.top = "50%";
      oldSprite.style.left = "50%";
      oldSprite.style.transform = "translate(-50%, -50%)";
      oldSprite.style.width = "150px";
      oldSprite.style.height = "150px";
      oldSprite.style.backgroundImage = `url(${digimon.spriteUrl})`;
      oldSprite.style.backgroundSize = "contain";
      oldSprite.style.backgroundPosition = "center";
      oldSprite.style.backgroundRepeat = "no-repeat";
      oldSprite.style.animation = "evolveOut 2s forwards";
      
      // Evolution light
      let light = document.createElement("div");
      light.style.position = "absolute";
      light.style.top = "50%";
      light.style.left = "50%";
      light.style.transform = "translate(-50%, -50%)";
      light.style.width = "0";
      light.style.height = "0";
      light.style.backgroundColor = "#fff";
      light.style.borderRadius = "50%";
      light.style.opacity = "0";
      light.style.boxShadow = "0 0 50px 30px rgba(255, 255, 255, 0.8)";
      light.style.animation = "evolutionLight 2s forwards";
      
      // New form sprite
      let newSprite = document.createElement("div");
      newSprite.style.position = "absolute";
      newSprite.style.top = "50%";
      newSprite.style.left = "50%";
      newSprite.style.transform = "translate(-50%, -50%) scale(0)";
      newSprite.style.width = "180px";
      newSprite.style.height = "180px";
      newSprite.style.backgroundImage = `url(${newForm.spriteUrl})`;
      newSprite.style.backgroundSize = "contain";
      newSprite.style.backgroundPosition = "center";
      newSprite.style.backgroundRepeat = "no-repeat";
      newSprite.style.opacity = "0";
      newSprite.style.animation = "evolveIn 1.5s forwards 1.5s";
      
      // Evolution text
      let text = document.createElement("div");
      text.style.position = "absolute";
      text.style.bottom = "30px";
      text.style.left = "0";
      text.style.width = "100%";
      text.style.textAlign = "center";
      text.style.color = "#fff";
      text.style.fontSize = "20px";
      text.style.fontWeight = "bold";
      text.style.opacity = "0";
      text.style.textShadow = "0 0 10px rgba(255, 255, 255, 0.5)";
      text.style.animation = "fadeIn 0.5s forwards 3s";
      text.innerHTML = `Evolution Complete!`;
      
      // Add evolution animation styles
      let style = document.createElement("style");
      style.innerHTML = `
        @keyframes evolveOut {
          0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
          100% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
        }
        @keyframes evolutionLight {
          0% { opacity: 0; width: 0; height: 0; }
          50% { opacity: 1; width: 200px; height: 200px; }
          100% { opacity: 0; width: 300px; height: 300px; }
        }
        @keyframes evolveIn {
          0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
          50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
          100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes fadeIn {
          0% { opacity: 0; }
          100% { opacity: 1; }
        }
      `;
      
      // Assemble everything
      container.appendChild(oldSprite);
      container.appendChild(light);
      container.appendChild(newSprite);
      container.appendChild(text);
      
      modal.appendChild(container);
      modal.appendChild(style);
      
      document.body.appendChild(modal);
      
      // Close the modal after animation completes
      setTimeout(() => {
        document.body.removeChild(modal);
      }, 5000);
    }

    // Track battle-specific conditions for evolution
    function trackEvolutionRequirements(digimon, battleData) {
      // Initialize tracking properties if not exist
      if (!digimon.battleWins) digimon.battleWins = 0;
      if (!digimon.defeatedTypes) digimon.defeatedTypes = {};
      if (!digimon.moveTypeUses) digimon.moveTypeUses = {};
      if (!digimon.perfectBattles) digimon.perfectBattles = 0;
      
      // Track battle wins
      if (battleData.win) {
        digimon.battleWins++;
        
        // Track defeated type
        if (battleData.enemy && battleData.enemy.type) {
          if (!digimon.defeatedTypes[battleData.enemy.type]) {
            digimon.defeatedTypes[battleData.enemy.type] = 0;
          }
          digimon.defeatedTypes[battleData.enemy.type]++;
        }
        
        // Track perfect battles (no damage taken)
        if (battleData.damageTaken === 0) {
          digimon.perfectBattles++;
        }
      }
      
      // Track max HP loss percent in a single hit
      if (battleData.maxDamagePercent > (digimon.maxHpLossPercent || 0)) {
        digimon.maxHpLossPercent = battleData.maxDamagePercent;
      }
    }

    // Integration with battle system - call this at end of battle
    function updateEvolutionProgress(digimon, battleData) {
      trackEvolutionRequirements(digimon, battleData);
    }

    // When using a move, track move type usage
    function trackMoveTypeUsage(digimon, moveType) {
      if (!digimon.moveTypeUses) digimon.moveTypeUses = {};
      if (!digimon.moveTypeUses[moveType]) digimon.moveTypeUses[moveType] = 0;
      digimon.moveTypeUses[moveType]++;
    }

    // At end of battle, update evolution requirements
    function endBattleWin() {
      // Update evolution tracking for active Digimon
      let activeDigimon = gameState.party[activePlayerDigimonIndex];
      if (activeDigimon) {
        // Set win flag and update evolution progress
        if (activeDigimon.battleData) {
          activeDigimon.battleData.win = true;
        }
        updateEvolutionProgress(activeDigimon, activeDigimon.battleData || {win: true});
        // Reset battle data for next battle
        activeDigimon.battleData = {};
      }
      
      // Award gold for winning the battle
      let goldReward = 50 + (gameState.roundNumber * 5) + Math.floor(Math.random() * 30);
      gameState.gold += goldReward;
      logToBattle(`You earned ${goldReward} gold!`);
      
      setTimeout(() => goToRewardSelection(), 1000);
    }

    function endBattleLose() {
      logToBattle("All your Digimon have been defeated!");
      logToBattle("Game Over!");
      
      setTimeout(() => {
        endRun();
      }, 2000);
    }

    /* G. REWARDS & ROUND FLOW */
    function goToRewardSelection() {
      document.getElementById("battle-screen").style.display = "none";
      generateRewards();
      document.getElementById("reward-selection").style.display = "flex";
    }

    function generateRewards() {
      let container = document.getElementById("reward-grid");
      container.innerHTML = "";
      
      // Number of rewards based on round
      let rewardCount = 5;
      if (gameState.permanentUpgrades.additionalReward) rewardCount++;
      
      // Reward options based on game progress
      let pool = [];
      
      // Common rewards (40%)
      for (let i = 0; i < 40; i++) pool.push("Common");
      
      // Uncommon rewards (30%) 
      for (let i = 0; i < 30; i++) pool.push("Uncommon");
      
      // Rare rewards (20%)
      for (let i = 0; i < 20; i++) pool.push("Rare");
      
      // Very rare rewards (8%)
      for (let i = 0; i < 8; i++) pool.push("VeryRare");
      
      // Ultra rare rewards (2%) 
      for (let i = 0; i < 2; i++) pool.push("UltraRare");
      
      // Create reward cards
      for (let i = 0; i < rewardCount; i++) {
        let rarity = pool[Math.floor(Math.random() * pool.length)];
        let reward = generateRewardByRarity(rarity);
        
        let div = document.createElement("div");
        div.className = "reward-card";
        div.setAttribute("data-reward", JSON.stringify(reward));
        
        let icon = getRewardIcon(reward.type);
        
        div.innerHTML = `
          <div class="reward-icon">${icon}</div>
          <div class="reward-name">${reward.name}</div>
          <div class="reward-description">${reward.description || ""}</div>
        `;
        
        div.onclick = () => {
          if (gameState.permanentUpgrades.multipleRewards) {
            div.classList.toggle("selected");
        } else {
            document.querySelectorAll(".reward-card").forEach(card => card.classList.remove("selected"));
            div.classList.add("selected");
          }
        };
        
        container.appendChild(div);
      }
    }

    function getRewardIcon(type) {
      switch (type) {
        case "gold": return "💰";
        case "exp": return "✨";
        case "item": return "🧪";
        case "decard": return "🃏";
        case "digihex": return "📦";
        case "stats": return "📈";
        case "digicrystals": return "💎";
        default: return "🎁";
      }
    }

    function generateRewardByRarity(rarity) {
      switch (rarity) {
        case "Common":
          return getCommonReward();
        case "Uncommon":
          return getUncommonReward();
        case "Rare":
          return getRareReward();
        case "VeryRare":
          return getVeryRareReward();
        case "UltraRare":
          return getUltraRareReward();
        default:
          return getCommonReward();
      }
    }

    function getCommonReward() {
      let rewards = [
        { type: "exp", name: "Small EXP Boost", value: 100, description: "+100 EXP to one Digimon" },
        { type: "gold", name: "Minor Gold", value: 100 + Math.floor(Math.random() * 100), description: "Extra gold" },
        { type: "item", name: "Potion", value: 1, description: "Restores 50 HP" },
        { type: "digihex", name: "Basic DigiHex", value: 1, description: "1x capture rate" },
        { type: "decard", name: "Common DE Card", rarity: "Common", description: "Random common DE Strike card" }
      ];
      
      return rewards[Math.floor(Math.random() * rewards.length)];
    }

    function getUncommonReward() {
      let rewards = [
        { type: "exp", name: "Medium EXP Boost", value: 250, description: "+250 EXP to one Digimon" },
        { type: "gold", name: "Moderate Gold", value: 300 + Math.floor(Math.random() * 200), description: "Extra gold" },
        { type: "item", name: "Super Potion", value: 1, description: "Restores 150 HP" },
        { type: "digihex", name: "Great DigiHex", value: 1, description: "1.5x capture rate" },
        { type: "decard", name: "Uncommon DE Card", rarity: "Uncommon", description: "Random uncommon DE Strike card" },
        { type: "item", name: "Anti-Virus", value: 1, description: "Cures status effects" }
      ];
      
      return rewards[Math.floor(Math.random() * rewards.length)];
    }

    function getRareReward() {
      let rewards = [
        { type: "exp", name: "Large EXP Boost", value: 500, description: "+500 EXP to one Digimon" },
        { type: "gold", name: "Major Gold", value: 700 + Math.floor(Math.random() * 300), description: "Extra gold" },
        { type: "item", name: "Max Potion", value: 1, description: "Fully restores HP" },
        { type: "digihex", name: "Ultra DigiHex", value: 1, description: "2x capture rate" },
        { type: "decard", name: "Rare DE Card", rarity: "Rare", description: "Random rare DE Strike card" },
        { type: "item", name: "Data Core", value: 1, description: "Evolution item" }
      ];
      
      return rewards[Math.floor(Math.random() * rewards.length)];
    }

    function getVeryRareReward() {
      let rewards = [
        { type: "exp", name: "Massive EXP Boost", value: 1000, description: "+1000 EXP to one Digimon" },
        { type: "gold", name: "Huge Gold", value: 1500 + Math.floor(Math.random() * 500), description: "Extra gold" },
        { type: "digihex", name: "Master DigiHex", value: 1, description: "3x capture rate" },
        { type: "decard", name: "Very Rare DE Card", rarity: "VeryRare", description: "Random very rare DE Strike card" },
        { type: "stats", name: "Stat Boost", value: 10, description: "+10 to a random stat" },
        { type: "digicrystals", name: "DigiCrystals", value: 50 + Math.floor(Math.random() * 50), description: "Permanent meta currency" }
      ];
      
      return rewards[Math.floor(Math.random() * rewards.length)];
    }

    function getUltraRareReward() {
      let rewards = [
        { type: "exp", name: "Ultimate EXP Boost", value: 2000, description: "+2000 EXP to one Digimon" },
        { type: "gold", name: "Fortune", value: 3000 + Math.floor(Math.random() * 2000), description: "Extra gold" },
        { type: "item", name: "Chrome Digizoid", value: 1, description: "Ultra rare evolution material" },
        { type: "digicrystals", name: "DigiCrystal Treasure", value: 200 + Math.floor(Math.random() * 100), description: "Large amount of meta currency" },
        { type: "decard", name: "Ultra Rare DE Card", rarity: "UltraRare", description: "Random ultra rare DE Strike card" }
      ];
      
      return rewards[Math.floor(Math.random() * rewards.length)];
    }

    function confirmRewardSelection() {
      let selected = document.querySelectorAll(".reward-card.selected");
      
      if (selected.length === 0) {
        alert("Please select at least one reward!");
        return;
      }
      
      selected.forEach(card => {
        let rewardData = JSON.parse(card.getAttribute("data-reward"));
        applyReward(rewardData);
      });
      
      document.getElementById("reward-selection").style.display = "none";
      proceedNextRound();
    }

    function applyReward(reward) {
      switch (reward.type) {
        case "gold":
          gameState.gold += reward.value;
          logToBattle(`Gained ${reward.value} gold!`);
          break;
          
        case "exp":
          if (gameState.party.length > 0) {
            // Apply to active Digimon for now - could add selection
            let digimon = gameState.party[activePlayerDigimonIndex];
            digimon.exp += reward.value;
            logToBattle(`${digimon.name} gained ${reward.value} EXP!`);
            
            // Check for level up
            if (digimon.exp >= digimon.expToNext) {
              levelUp(digimon);
            }
          }
          break;
          
        case "item":
          if (!gameState.inventory[reward.name]) {
            gameState.inventory[reward.name] = 0;
          }
          gameState.inventory[reward.name] += reward.value;
          logToBattle(`Obtained ${reward.name}!`);
          break;
          
        case "digihex":
          if (!gameState.inventory[reward.name]) {
            gameState.inventory[reward.name] = 0;
          }
          gameState.inventory[reward.name] += reward.value;
          logToBattle(`Obtained ${reward.name}!`);
          break;
          
        case "decard":
          let card = getRandomDECardByRarity(reward.rarity);
          if (card) {
            gameState.cardLibrary.push(card);
            logToBattle(`Found DE Card: ${card.name}!`);
          }
          break;
          
        case "stats":
          if (gameState.party.length > 0) {
            let digimon = gameState.party[activePlayerDigimonIndex];
            // Pick a random stat to boost
            let stats = ["HP", "ATK", "DEF", "SATK", "SDEF", "DEATK", "DEDEF", "SPD"];
            let stat = stats[Math.floor(Math.random() * stats.length)];
            
            digimon.baseStats[stat] += reward.value;
            digimon.currentStats[stat] += reward.value;
            
            // If HP was boosted, increase current HP too
            if (stat === "HP") {
              digimon.currentHP += reward.value;
            }
            
            logToBattle(`${digimon.name}'s ${stat} increased by ${reward.value}!`);
          }
          break;
          
        case "digicrystals":
          gameState.digicrystals += reward.value;
          logToBattle(`Gained ${reward.value} DigiCrystals!`);
          break;
      }
    }

    function proceedNextRound() {
      gameState.roundNumber++;
      
      // Update round display
      document.getElementById("round-display").textContent = gameState.roundNumber;
      
      // Check for special events
      let encounterType = determineEncounterType();
      
      switch (encounterType) {
        case "tamer":
          startTamerBattle();
          break;
          
        case "boss":
          startBossBattle();
          break;
          
        case "shop":
          openShop();
          break;
          
        default:
          randomEncounter();
          break;
      }
    }

    function determineEncounterType() {
      // Tamer battle?
      if (gameState.roundNumber >= gameState.nextTamerBattle) {
        gameState.nextTamerBattle += 25;
        return "tamer";
      }
      
      // Boss battle?
      for (let boss of bossList) {
        if (boss.round === gameState.roundNumber) {
          return "boss";
        }
      }
      
      // Shop?
      if (gameState.roundNumber >= gameState.nextShop) {
        gameState.nextShop += Math.floor(5 + Math.random() * 5);
        return "shop";
      }
      
      // Default: random encounter
      return "random";
    }

    function startTamerBattle() {
      if (tamerBattles.length === 0) {
        randomEncounter();
        return;
      }
      
      let tamerIndex = Math.min(Math.floor(gameState.roundNumber / 25) - 1, tamerBattles.length - 1);
      if (tamerIndex < 0) tamerIndex = 0;
      
      let tamer = tamerBattles[tamerIndex];
      logToBattle(`Tamer ${tamer.name} challenges you!`);
      
      // Use first Digimon in tamer's team for now
      if (tamer.digimonTeam.length > 0) {
        startBattle(tamer.digimonTeam[0]);
      } else {
        randomEncounter();
      }
    }

    function startBossBattle() {
      let boss = bossList.find(b => b.round === gameState.roundNumber);
      if (!boss) {
        randomEncounter();
        return;
      }
      
      logToBattle(`BOSS: ${boss.name} appears!`);
      startBattle(boss.name);
    }

    /* H. SHOP */
    function openShop() {
      document.getElementById("shop-gold-display").textContent = gameState.gold;
      document.getElementById("shop-items").innerHTML = "";
      document.getElementById("shop-screen").style.display = "flex";
      
      // Generate shop inventory
      generateShopItems();
    }

    function generateShopItems() {
      let container = document.getElementById("shop-items");
      let itemCount = 6 + Math.floor(Math.random() * 3); // 6-8 items
      
      let pool = [];
      
      // Add consumable items
      pool.push({ name: "Potion", price: 50, type: "item", description: "Restores 50 HP" });
      pool.push({ name: "Super Potion", price: 100, type: "item", description: "Restores 150 HP" });
      pool.push({ name: "Max Potion", price: 200, type: "item", description: "Fully restores HP" });
      pool.push({ name: "Anti-Virus", price: 80, type: "item", description: "Cures status effects" });
      
      // Add PP restoration items
      pool.push({ name: "Ether", price: 60, type: "item", description: "Restores 10 PP to one move" });
      pool.push({ name: "Max Ether", price: 120, type: "item", description: "Fully restores PP to one move" });
      pool.push({ name: "Elixir", price: 150, type: "item", description: "Restores 10 PP to all moves" });
      pool.push({ name: "Max Elixir", price: 300, type: "item", description: "Fully restores all PP" });
      
      // Add DigiHex (capture items)
      pool.push({ name: "Basic DigiHex", price: 75, type: "item", description: "1x capture rate" });
      pool.push({ name: "Great DigiHex", price: 150, type: "item", description: "1.5x capture rate" });
      pool.push({ name: "Ultra DigiHex", price: 300, type: "item", description: "2x capture rate" });
      
      // Add evolution items (later rounds)
      if (gameState.roundNumber >= 15) {
        pool.push({ name: "Data Core", price: 400, type: "item", description: "Evolution material" });
        pool.push({ name: "Virus Booster", price: 400, type: "item", description: "For virus evolutions" });
      }
      
      if (gameState.roundNumber >= 30) {
        pool.push({ name: "Holy Ring", price: 600, type: "item", description: "For holy evolutions" });
        pool.push({ name: "Dark Core", price: 600, type: "item", description: "For dark evolutions" });
      }
      
      // Add DE cards
      pool.push({ name: "Random DE Card", price: 200, type: "decard", description: "Random DE Strike card" });
      
      // Generate random selection
      let shopItems = [];
      for (let i = 0; i < itemCount; i++) {
        let itemIndex = Math.floor(Math.random() * pool.length);
        let item = JSON.parse(JSON.stringify(pool[itemIndex])); // Clone
        
        // Add some price variance (±20%)
        let variance = 1 + (Math.random() * 0.4 - 0.2);
        item.price = Math.floor(item.price * variance);
        
        shopItems.push(item);
      }
      
      // Render items
      shopItems.forEach(item => {
        let itemEl = document.createElement("div");
        itemEl.className = "shop-item-card";
        
        let icon = item.type === "decard" ? "🃏" : "🧪";
        
        itemEl.innerHTML = `
          <div class="shop-icon">${icon}</div>
          <div class="shop-name">${item.name}</div>
          <div class="shop-description">${item.description}</div>
          <div class="shop-price">${item.price} G</div>
        `;
        
        itemEl.onclick = () => buyItem(item);
        
        container.appendChild(itemEl);
      });
    }

    function buyItem(item) {
      if (gameState.gold < item.price) {
        logToBattle("Not enough gold!");
        return;
      }
      
      gameState.gold -= item.price;
      document.getElementById("shop-gold-display").textContent = gameState.gold;
      
      if (item.type === "decard") {
        let card = getRandomDECard();
        if (card) {
          gameState.cardLibrary.push(card);
          logToBattle(`Bought DE Card: ${card.name}!`);
        }
      } else {
        if (!gameState.inventory[item.name]) {
          gameState.inventory[item.name] = 0;
        }
        gameState.inventory[item.name]++;
        logToBattle(`Bought ${item.name}!`);
      }
    }

    function closeShop() {
      document.getElementById("shop-screen").style.display = "none";
      randomEncounter();
    }

    /* I. CAPTURE */
    function openCaptureOverlay() {
      document.getElementById("capture-overlay").style.display = "flex";
      renderCaptureOptions();
    }

    function renderCaptureOptions() {
      let container = document.getElementById("digihex-options");
      container.innerHTML = "";
      
      // Find all DigiHex items in inventory
      let digihexes = [];
      for (let item in gameState.inventory) {
        if (item.includes("DigiHex") && gameState.inventory[item] > 0) {
          digihexes.push({
            name: item,
            count: gameState.inventory[item]
          });
        }
      }
      
      if (digihexes.length === 0) {
        container.innerHTML = "<p>You don't have any DigiHex items!</p>";
        return;
      }
      
      // Create buttons for each DigiHex type
      digihexes.forEach(hex => {
        let btn = document.createElement("button");
        btn.className = "digimon-btn";
        btn.innerHTML = `${hex.name} (x${hex.count})`;
        btn.onclick = () => attemptCapture(hex.name);
        container.appendChild(btn);
      });
    }

    function closeCaptureOverlay() {
      document.getElementById("capture-overlay").style.display = "none";
    }

    function attemptCapture(digihexName) {
      if (!gameState.inventory[digihexName] || gameState.inventory[digihexName] < 1) {
        logToBattle("No DigiHex left!");
        return;
      }
      
      let enemy = gameState.activeEnemy;
      if (!enemy) return;
      
      // Base capture chance
      let chance = 30;
      
      // HP ratio affects catch rate
      let hpRatio = enemy.currentHP / enemy.currentStats.HP;
      chance += Math.floor((1 - hpRatio) * 50);
      
      // DigiHex type bonus
      if (digihexName === "Great DigiHex") chance *= 1.5;
      if (digihexName === "Ultra DigiHex") chance *= 2;
      if (digihexName === "Master DigiHex") chance *= 3;
      
      // Player's luck affects capture rate
      let playerDigimon = gameState.party[activePlayerDigimonIndex];
      if (playerDigimon && playerDigimon.luck) {
        chance += playerDigimon.luck;
      }
      
      // Status effects help capture
      if (enemy.status === "glitch") chance += 20;
      
      // Limit max chance to 90%
      chance = Math.min(90, chance);
      
      // Attempt capture
      if (Math.random() * 100 < chance) {
        logToBattle(`Captured ${enemy.name} (ID #${enemy.uniqueID})!`);
        
        // Add to party if space available
        let maxPartySize = gameState.permanentUpgrades.party_size ? 6 : 5;
        if (gameState.party.length < maxPartySize) {
          gameState.party.push(enemy);
        } else {
          logToBattle("Party full! Sent to storage instead.");
        }
        
        // Add to caught collection
        gameState.caughtDigimon.push(enemy);
        gameState.captureCount++;
        
        // Save global state
        saveGlobalState();
        
        // End battle with win
        gameState.activeEnemy = null;
        document.getElementById("capture-overlay").style.display = "none";
        endBattleWin();
      } else {
        logToBattle("Capture failed!");
        // Use up the DigiHex
        gameState.inventory[digihexName]--;
        closeCaptureOverlay();
        
        // Enemy's turn
        enemyAction();
      }
    }

    /* J. DIGISCAN */
    function openScanOverlay() {
      let enemy = gameState.activeEnemy;
      if (!enemy) return;
      
      document.getElementById("scan-overlay").style.display = "flex";
      
      let scanInfo = document.getElementById("scan-info");
      scanInfo.innerHTML = "";
      
      // Create the scan info container
      let infoContainer = document.createElement("div");
      infoContainer.className = "scan-info-container";
      
      // Create header with sprite and basic info
      let header = document.createElement("div");
      header.className = "scan-header";
      
      let sprite = document.createElement("div");
      sprite.className = "scan-sprite";
      sprite.style.backgroundImage = `url(${enemy.spriteUrl})`;
      
      let basics = document.createElement("div");
      basics.className = "scan-basics";
      
      let variantClass = enemy.variant.toLowerCase();
      
      basics.innerHTML = `
        <div class="scan-name">${enemy.name} <span class="variant-${variantClass}">${enemy.variant}</span></div>
        <div class="digimon-type type-${enemy.type.toLowerCase()}">${enemy.type}</div>
        <div>ID #${enemy.uniqueID}</div>
      `;
      
      header.appendChild(sprite);
      header.appendChild(basics);
      infoContainer.appendChild(header);
      
      // Create details section
      let details = document.createElement("div");
      details.className = "scan-details";
      
      details.innerHTML = `
        <p><span class="scan-label">Stage:</span> ${enemy.stage}</p>
        <p><span class="scan-label">Level:</span> ${enemy.level}</p>
        <p><span class="scan-label">HP:</span> ${enemy.currentHP}/${enemy.currentStats.HP}</p>
      `;
      
      infoContainer.appendChild(details);
      
      // Create stats section
      let stats = document.createElement("div");
      stats.className = "scan-stats";
      
      for (let stat in enemy.currentStats) {
        if (stat === "HP") continue; // Already shown above
        
        let statDiv = document.createElement("div");
        statDiv.className = "scan-stat";
        statDiv.innerHTML = `<span class="scan-label">${stat}:</span> ${enemy.currentStats[stat]}`;
        stats.appendChild(statDiv);
      }
      
      infoContainer.appendChild(stats);
      
      // Create moves section
      let moves = document.createElement("div");
      moves.className = "scan-moves";
      
      let movesTitle = document.createElement("div");
      movesTitle.className = "scan-moves-title";
      movesTitle.textContent = "Moves";
      moves.appendChild(movesTitle);
      
      enemy.moves.forEach(moveName => {
        let move = MoveDB[moveName];
        if (!move) return;
        
        let moveDiv = document.createElement("div");
        moveDiv.className = "scan-move";
        
        moveDiv.innerHTML = `
          <span>${moveName}</span>
          <span class="move-type type-${move.type.toLowerCase()}">${move.type}</span>
        `;
        
        moves.appendChild(moveDiv);
      });
      
      infoContainer.appendChild(moves);
      scanInfo.appendChild(infoContainer);
    }

    function closeScanOverlay() {
      document.getElementById("scan-overlay").style.display = "none";
    }

    /* K. DE STRIKE */
    function openDECardOverlay() {
      document.getElementById("de-card-overlay").style.display = "flex";
      renderDECardLibrary();
    }

    function closeDECardOverlay() {
      document.getElementById("de-card-overlay").style.display = "none";
    }

    function renderDECardLibrary() {
      let container = document.getElementById("de-card-list");
      container.innerHTML = "";
      
      if (gameState.cardLibrary.length === 0) {
        container.innerHTML = "<p>You don't have any DE cards!</p>";
        return;
      }
      
      gameState.cardLibrary.forEach((card, i) => {
        let cardElement = document.createElement("div");
        cardElement.className = "de-card";
        cardElement.onclick = () => useDECard(i);
        
        let rarityClass = card.rarity.toLowerCase().replace(/\s+/g, '');
        
        cardElement.innerHTML = `
          <div class="de-card-header">
            <div class="de-card-name">${card.name}</div>
            <div class="de-card-power">${card.basePower}</div>
            <div class="de-card-rarity rarity-${rarityClass}">${card.rarity}</div>
            <div class="de-card-type type-${card.type.toLowerCase()}">${card.type}</div>
          </div>
          <div class="de-card-description">${card.description || ""}</div>
        `;
        
        container.appendChild(cardElement);
      });
    }

    function playDEStrikeAnimation(cardName, cardType, cardDescription, callback) {
      // Create main animation container
      const container = document.createElement('div');
      container.className = 'de-strike-animation-container';

      // Phase 1: Reality Fracture Overlay
      const realityFracture = document.createElement('div');
      realityFracture.className = 'reality-fracture-overlay';
      container.appendChild(realityFracture);

      // Phase 2: Digital Glitch Matrix
      const glitchMatrix = document.createElement('div');
      glitchMatrix.className = 'glitch-matrix';
      container.appendChild(glitchMatrix);

      // Phase 3: Holographic Card Container
      const holoCardContainer = document.createElement('div');
      holoCardContainer.className = 'holo-card-container';
      
      const holoCard = document.createElement('div');
      holoCard.className = 'holo-card';
      
      const cardFront = document.createElement('div');
      cardFront.className = 'card-front';
      
      const cardTitle = document.createElement('div');
      cardTitle.className = 'card-title';
      cardTitle.textContent = cardName || 'DE STRIKE';
      
      const cardSymbol = document.createElement('div');
      cardSymbol.className = 'card-symbol';
      // Set symbol based on card type
      switch(cardType) {
        case 'Data': cardSymbol.textContent = '◆'; break;
        case 'Vaccine': cardSymbol.textContent = '▲'; break;
        case 'Virus': cardSymbol.textContent = '●'; break;
        default: cardSymbol.textContent = '⬢';
      }
      
      const cardTypeBadge = document.createElement('div');
      cardTypeBadge.className = 'card-type-badge';
      cardTypeBadge.textContent = cardType || 'DATA';
      
      cardFront.appendChild(cardTitle);
      cardFront.appendChild(cardSymbol);
      cardFront.appendChild(cardTypeBadge);
      holoCard.appendChild(cardFront);
      holoCardContainer.appendChild(holoCard);
      container.appendChild(holoCardContainer);

      // Phase 4: Quantum Data Streams
      const streamContainer = document.createElement('div');
      streamContainer.className = 'quantum-stream-container';
      
      for (let i = 1; i <= 6; i++) {
        const stream = document.createElement('div');
        stream.className = `data-stream stream-${i}`;
        streamContainer.appendChild(stream);
      }
      container.appendChild(streamContainer);

      // Phase 5: Holographic UI Overlay
      const holoUI = document.createElement('div');
      holoUI.className = 'holo-ui-overlay';
      
      const scanLine = document.createElement('div');
      scanLine.className = 'scan-line';
      holoUI.appendChild(scanLine);
      
      // UI corner elements
      const corners = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
      corners.forEach(corner => {
        const uiCorner = document.createElement('div');
        uiCorner.className = `ui-corner ${corner}`;
        holoUI.appendChild(uiCorner);
      });
      
      container.appendChild(holoUI);

      // Phase 6: Dimensional Tear Effect
      const dimensionalTear = document.createElement('div');
      dimensionalTear.className = 'dimensional-tear';
      container.appendChild(dimensionalTear);

      // Phase 7: Energy Convergence
      const energyConvergence = document.createElement('div');
      energyConvergence.className = 'energy-convergence';
      container.appendChild(energyConvergence);

      // Phase 8: Reality Reconstruction
      const realityReconstruction = document.createElement('div');
      realityReconstruction.className = 'reality-reconstruction';
      container.appendChild(realityReconstruction);

      // Phase 9: Screen Distortion
      const screenDistortion = document.createElement('div');
      screenDistortion.className = 'screen-distortion';
      container.appendChild(screenDistortion);

      // Premium Text Effects
      const deActivateText = document.createElement('div');
      deActivateText.className = 'premium-text de-activate-text';
      deActivateText.textContent = 'DE ACTIVATE';
      container.appendChild(deActivateText);

      const systemOverrideText = document.createElement('div');
      systemOverrideText.className = 'premium-text system-override-text';
      systemOverrideText.textContent = 'SYSTEM OVERRIDE';
      container.appendChild(systemOverrideText);

      // Add to document
      document.body.appendChild(container);

      // Screen shake and visual effects
      const gameContainer = document.getElementById('game-container');
      const enemySprite = document.getElementById('enemy-digimon-sprite');
      
      // Progressive screen shake during animation
      setTimeout(() => {
        if (gameContainer) {
          gameContainer.style.animation = 'screenShakeLight 0.3s ease-out';
        }
      }, 2000);

      setTimeout(() => {
        if (gameContainer) {
          gameContainer.style.animation = 'screenShakeMedium 0.4s ease-out';
        }
      }, 3000);

      setTimeout(() => {
        if (gameContainer) {
          gameContainer.style.animation = 'screenShakeHeavy 0.5s ease-out';
        }
        if (enemySprite) {
          enemySprite.style.animation = 'enemyShakeIntense 0.8s ease-out';
        }
      }, 3800);

      // Clean up and trigger callback
      setTimeout(() => {
        if (gameContainer) {
          gameContainer.style.animation = '';
        }
        if (enemySprite) {
          enemySprite.style.animation = '';
        }
        
        document.body.removeChild(container);
        
        if (typeof callback === 'function') {
          callback();
        }
      }, 4500);

      // Add additional screen shake keyframes
      if (!document.querySelector('#de-shake-styles')) {
        const style = document.createElement('style');
        style.id = 'de-shake-styles';
        style.innerHTML = `
          @keyframes screenShakeLight {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-2px) translateY(1px); }
            50% { transform: translateX(2px) translateY(-1px); }
            75% { transform: translateX(-1px) translateY(1px); }
          }
          
          @keyframes screenShakeMedium {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-4px) translateY(2px); }
            40% { transform: translateX(4px) translateY(-2px); }
            60% { transform: translateX(-3px) translateY(2px); }
            80% { transform: translateX(3px) translateY(-1px); }
          }
          
          @keyframes screenShakeHeavy {
            0%, 100% { transform: translateX(0); }
            10% { transform: translateX(-8px) translateY(4px); }
            20% { transform: translateX(8px) translateY(-4px); }
            30% { transform: translateX(-6px) translateY(3px); }
            40% { transform: translateX(6px) translateY(-3px); }
            50% { transform: translateX(-4px) translateY(2px); }
            60% { transform: translateX(4px) translateY(-2px); }
            70% { transform: translateX(-3px) translateY(1px); }
            80% { transform: translateX(3px) translateY(-1px); }
            90% { transform: translateX(-1px) translateY(1px); }
          }
          
          @keyframes enemyShakeIntense {
            0%, 100% { transform: translateY(-50%) scaleX(-1) translateX(0); }
            10% { transform: translateY(-50%) scaleX(-1) translateX(-15px); }
            20% { transform: translateY(-50%) scaleX(-1) translateX(12px); }
            30% { transform: translateY(-50%) scaleX(-1) translateX(-10px); }
            40% { transform: translateY(-50%) scaleX(-1) translateX(8px); }
            50% { transform: translateY(-50%) scaleX(-1) translateX(-6px); }
            60% { transform: translateY(-50%) scaleX(-1) translateX(4px); }
            70% { transform: translateY(-50%) scaleX(-1) translateX(-3px); }
            80% { transform: translateY(-50%) scaleX(-1) translateX(2px); }
            90% { transform: translateY(-50%) scaleX(-1) translateX(-1px); }
          }
        `;
        document.head.appendChild(style);
      }
    }

    function useDECard(index) {
      let card = gameState.cardLibrary[index];
      if (!card) return;
      
      closeDECardOverlay();
      
      let user = gameState.party[activePlayerDigimonIndex];
      let target = gameState.activeEnemy;
      
      if (!user || !target) return;
      
      // Play the animation first, then continue with attack logic
      playDEStrikeAnimation(card.name, card.type, card.description, () => {
        logToBattle(`${user.name} used DE Card: ${card.name}!`);
        
        // Calculate damage
        let atk = user.currentStats.DEATK;
        let def = target.currentStats.DEDEF;
        let power = card.basePower || 0;
        let typeEffect = getTypeEffectiveness(card.type, target.type);
        let stab = (user.type.includes(card.type)) ? 1.5 : 1;
        
        let damage = 0;
        if (power > 0) {
          // DE Strikes use a more powerful formula
          damage = Math.floor((((2 * user.level / 5 + 2) * atk * power / def) / 40 + 2) * typeEffect * stab);
          
          // Random factor (90-100%) - DE Strikes are more consistent
          damage = Math.floor(damage * (0.9 + Math.random() * 0.1));
        }
        
        if (typeEffect > 1) {
          logToBattle("It's super effective!");
        } else if (typeEffect < 1 && typeEffect > 0) {
          logToBattle("It's not very effective...");
        } else if (typeEffect === 0) {
          logToBattle("It has no effect!");
          damage = 0;
        }
        
        if (damage > 0) {
          target.currentHP = Math.max(0, target.currentHP - damage);
          logToBattle(`Dealt ${damage} damage!`);
        }
        
        // Apply DE card effects
        if (card.effect) {
          applyCardEffect(user, target, card);
        }
        
        // Remove the used card
        gameState.cardLibrary.splice(index, 1);
        
        // Update battle UI
        updateBattleUI();
        
        // Check if battle is over
        if (target.currentHP <= 0) {
          logToBattle(`${target.name} was defeated!`);
          awardExp(user, target);
          endBattleWin();
        } else {
          // Enemy turn
          enemyAction();
        }
      });
    }

    function applyCardEffect(user, target, card) {
      if (!card.effect) return;
      
      switch (card.effect) {
        case "selfDamage30":
          let damage = Math.floor(user.currentStats.HP * 0.3);
          user.currentHP = Math.max(1, user.currentHP - damage);
          logToBattle(`${user.name} took ${damage} recoil damage!`);
          break;
          
        case "skipNext":
          user.skipNextTurn = true;
          logToBattle(`${user.name} must recharge next turn!`);
          break;
          
        case "heal25":
          let healAmount = Math.floor(user.currentStats.HP * 0.25);
          user.currentHP = Math.min(user.currentStats.HP, user.currentHP + healAmount);
          logToBattle(`${user.name} recovered ${healAmount} HP!`);
          break;
          
        // More effects can be added here
      }
    }

    function getRandomDECard() {
      // Distribute rarities
      let roll = Math.random() * 100;
      let rarity = "Common";
      
      if (roll < 2) rarity = "UltraRare";
      else if (roll < 10) rarity = "VeryRare";
      else if (roll < 30) rarity = "Rare";
      else if (roll < 60) rarity = "Uncommon";
      
      return getRandomDECardByRarity(rarity);
    }

    function getRandomDECardByRarity(rarity) {
      // Filter cards by rarity
      let pool = DECardsDB.filter(c => c.rarity === rarity);
      
      if (pool.length === 0) return null;
      
      // Return a random card from the pool
      return JSON.parse(JSON.stringify(pool[Math.floor(Math.random() * pool.length)]));
    }

    /* L. PARTY OVERLAY */
    function openPartyOverlay() {
      document.getElementById("party-overlay").style.display = "flex";
      renderPartyInfo();
    }

    function closePartyOverlay() {
      document.getElementById("party-overlay").style.display = "none";
    }

    function renderPartyInfo() {
      let container = document.getElementById("party-info");
      container.innerHTML = "";
      
      if (gameState.party.length === 0) {
        container.innerHTML = "<p>Your party is empty!</p>";
        return;
      }
      
      gameState.party.forEach((digimon, i) => {
        let isActive = i === activePlayerDigimonIndex;
        
        let card = document.createElement("div");
        card.className = "party-digimon-card" + (isActive ? " active" : "");
        
        // Create sprite container
        let sprite = document.createElement("div");
        sprite.className = "party-sprite";
        sprite.style.backgroundImage = `url(${digimon.spriteUrl})`;
        
        // Create info container
        let info = document.createElement("div");
        info.className = "party-info";
        
        // Create header with name and level
        let header = document.createElement("div");
        header.className = "party-digimon-header";
        
        header.innerHTML = `
          <div class="party-digimon-name">${digimon.name} (ID #${digimon.uniqueID})</div>
          <div class="party-digimon-level">Lv. ${digimon.level}</div>
        `;
        
        // Create HP bar
        let hp = document.createElement("div");
        hp.className = "party-hp";
        
        let hpPercent = (digimon.currentHP / digimon.currentStats.HP) * 100;
        
        hp.innerHTML = `
          <div class="party-hp-bar">
            <div class="party-hp-fill" style="width: ${hpPercent}%"></div>
          </div>
          <div class="party-hp-text">${digimon.currentHP}/${digimon.currentStats.HP}</div>
        `;
        
        // Create moves list
        let moves = document.createElement("div");
        moves.className = "party-moves";
        
        digimon.moves.forEach(moveName => {
          let moveSpan = document.createElement("span");
          moveSpan.className = "party-move";
          moveSpan.textContent = moveName;
          moves.appendChild(moveSpan);
        });
        
        // Create actions
        let actions = document.createElement("div");
        actions.className = "party-actions";
        
        if (!isActive) {
          let switchBtn = document.createElement("button");
          switchBtn.className = "digimon-btn party-btn";
          switchBtn.textContent = "Switch In";
          switchBtn.onclick = (e) => {
            e.stopPropagation();
            switchActiveDigimon(i);
          };
          actions.appendChild(switchBtn);
        }
        
        let healBtn = document.createElement("button");
        healBtn.className = "digimon-btn party-btn";
        healBtn.textContent = "Heal";
        healBtn.onclick = (e) => {
          e.stopPropagation();
          openHealOptions(i);
        };
        actions.appendChild(healBtn);
        
        // Assemble everything
        info.appendChild(header);
        info.appendChild(hp);
        info.appendChild(moves);
        info.appendChild(actions);
        
        card.appendChild(sprite);
        card.appendChild(info);
        
        container.appendChild(card);
      });
    }

    function switchActiveDigimon(index) {
      if (index === activePlayerDigimonIndex) return;
      
      activePlayerDigimonIndex = index;
      closePartyOverlay();
      updateBattleUI();
      
      logToBattle(`Switched to ${gameState.party[index].name} (ID #${gameState.party[index].uniqueID})!`);
      
      // Enemy gets a free turn when switching
      enemyAction();
    }

    function openHealOptions(digimonIndex) {
      // Check if player has healing items
      let healingItems = [];
      
      for (let itemName in gameState.inventory) {
        if ((itemName.includes("Potion") || itemName === "Full Restore") && gameState.inventory[itemName] > 0) {
          healingItems.push(itemName);
        }
      }
      
      if (healingItems.length === 0) {
        alert("You don't have any healing items!");
        return;
      }
      
      // Create modal for healing options
      let modal = document.createElement("div");
      modal.style.position = "fixed";
      modal.style.top = "0";
      modal.style.left = "0";
      modal.style.width = "100%";
      modal.style.height = "100%";
      modal.style.backgroundColor = "rgba(0,0,0,0.8)";
      modal.style.display = "flex";
      modal.style.justifyContent = "center";
      modal.style.alignItems = "center";
      modal.style.zIndex = "1000";
      
      let content = document.createElement("div");
      content.style.backgroundColor = "#1c2541";
      content.style.padding = "20px";
      content.style.borderRadius = "8px";
      content.style.maxWidth = "300px";
      content.style.textAlign = "center";
      
      content.innerHTML = `
        <h3 style="margin-bottom:15px">Select Healing Item</h3>
      `;
      
      healingItems.forEach(item => {
        let btn = document.createElement("button");
        btn.className = "digimon-btn";
        btn.style.margin = "5px";
        btn.textContent = `${item} (x${gameState.inventory[item]})`;
        
        btn.onclick = function() {
          useHealingItem(item, digimonIndex);
          document.body.removeChild(modal);
        };
        
        content.appendChild(btn);
      });
      
      let cancelBtn = document.createElement("button");
      cancelBtn.className = "digimon-btn";
      cancelBtn.style.marginTop = "15px";
      cancelBtn.textContent = "Cancel";
      cancelBtn.onclick = function() {
        document.body.removeChild(modal);
      };
      
      content.appendChild(cancelBtn);
      modal.appendChild(content);
      document.body.appendChild(modal);
    }

    function useHealingItem(itemName, digimonIndex) {
      if (!gameState.inventory[itemName] || gameState.inventory[itemName] <= 0) {
        alert("You don't have any " + itemName + "!");
        return;
      }
      
      let digimon = gameState.party[digimonIndex];
      if (!digimon) return;
      
      let healAmount = 0;
      
      switch (itemName) {
        case "Potion":
          healAmount = 50;
          break;
        case "Super Potion":
          healAmount = 150;
          break;
        case "Max Potion":
        case "Full Restore":
          healAmount = digimon.currentStats.HP;
          break;
        default:
          healAmount = 50;
      }
      
      let oldHP = digimon.currentHP;
      digimon.currentHP = Math.min(digimon.currentStats.HP, digimon.currentHP + healAmount);
      let actualHeal = digimon.currentHP - oldHP;
      
      gameState.inventory[itemName]--;
      
      logToBattle(`Used ${itemName} on ${digimon.name}. Restored ${actualHeal} HP!`);
      
      // Clear status effects for Full Restore
      if (itemName === "Full Restore") {
        digimon.status = null;
        logToBattle(`${digimon.name}'s status effects were cleared!`);
      }
      
      // Update party display
      renderPartyInfo();
      
      // Update battle UI if active Digimon was healed
      if (digimonIndex === activePlayerDigimonIndex) {
        updateBattleUI();
      }
    }

    /* M. ITEM OVERLAY */
    function openItemOverlay() {
      document.getElementById("item-overlay").style.display = "flex";
      renderItemList();
    }

    function closeItemOverlay() {
      document.getElementById("item-overlay").style.display = "none";
    }

    function renderItemList() {
      let container = document.getElementById("item-list");
      container.innerHTML = "";
      
      let hasItems = false;
      
      for (let itemName in gameState.inventory) {
        let quantity = gameState.inventory[itemName];
        if (quantity <= 0) continue;
        
        hasItems = true;
        
        let itemDiv = document.createElement("div");
        itemDiv.className = "item-card";
        
        let icon = getItemIcon(itemName);
        
        itemDiv.innerHTML = `
          <div class="item-icon">${icon}</div>
          <div class="item-name">${itemName}</div>
          <div class="item-quantity">x${quantity}</div>
          <button class="digimon-btn" onclick="useItem('${itemName}')">Use</button>
        `;
        
        container.appendChild(itemDiv);
      }
      
      if (!hasItems) {
        container.innerHTML = "<p>You don't have any items!</p>";
      }
    }

    function getItemIcon(itemName) {
      if (itemName.includes("Potion")) return "🧪";
      if (itemName.includes("DigiHex")) return "📦";
      if (itemName.includes("Core") || itemName.includes("Booster")) return "💎";
      if (itemName.includes("Anti-")) return "💊";
      return "🔮";
    }

    function useItem(itemName) {
      if (!gameState.inventory[itemName] || gameState.inventory[itemName] <= 0) {
        alert("You don't have any " + itemName + "!");
        return;
      }
      
      let used = false;
      
      // Consumable items
      if (itemName.includes("Potion") || itemName === "Full Restore") {
        // For battle potions, just heal active Digimon
        let digimon = gameState.party[activePlayerDigimonIndex];
        if (!digimon) return;
        
        let healAmount = 0;
        
        switch (itemName) {
          case "Potion":
            healAmount = 50;
            break;
          case "Super Potion":
            healAmount = 150;
            break;
          case "Max Potion":
          case "Full Restore":
            healAmount = digimon.currentStats.HP;
            break;
          default:
            healAmount = 50;
        }
        
        let oldHP = digimon.currentHP;
        digimon.currentHP = Math.min(digimon.currentStats.HP, digimon.currentHP + healAmount);
        let actualHeal = digimon.currentHP - oldHP;
        
        logToBattle(`Used ${itemName} on ${digimon.name}. Restored ${actualHeal} HP!`);
        
        // Clear status effects for Full Restore
        if (itemName === "Full Restore") {
          digimon.status = null;
          logToBattle(`${digimon.name}'s status effects were cleared!`);
        }
        
        used = true;
        updateBattleUI();
      }
      
      // Status cures
      if (itemName === "Anti-Virus") {
        let digimon = gameState.party[activePlayerDigimonIndex];
        if (!digimon) return;
        
        if (!digimon.status) {
          logToBattle(`${digimon.name} doesn't have any status effects!`);
          return;
        }
        
        digimon.status = null;
        logToBattle(`${digimon.name}'s status effects were cured!`);
        used = true;
      }

      // PP restoration items
      if (itemName === "Ether") {
        let digimon = gameState.party[activePlayerDigimonIndex];
        if (!digimon) return;
        
        // Find a move with depleted PP to restore
        let moveToRestore = null;
        for (let moveName of digimon.moves) {
          let currentPP = digimon.movePP[moveName] || 0;
          let maxPP = MoveDB[moveName] ? MoveDB[moveName].pp : 0;
          if (currentPP < maxPP) {
            moveToRestore = moveName;
            break;
          }
        }
        
        if (!moveToRestore) {
          logToBattle(`${digimon.name}'s moves are already at full PP!`);
          return;
        }
        
        let currentPP = digimon.movePP[moveToRestore] || 0;
        let maxPP = MoveDB[moveToRestore] ? MoveDB[moveToRestore].pp : 0;
        let restored = Math.min(10, maxPP - currentPP);
        digimon.movePP[moveToRestore] = Math.min(maxPP, currentPP + 10);
        
        logToBattle(`Used ${itemName} on ${digimon.name}. Restored ${restored} PP to ${moveToRestore}!`);
        used = true;
        updateBattleUI();
      }

      if (itemName === "Max Ether") {
        let digimon = gameState.party[activePlayerDigimonIndex];
        if (!digimon) return;
        
        // Find a move with depleted PP to restore
        let moveToRestore = null;
        for (let moveName of digimon.moves) {
          let currentPP = digimon.movePP[moveName] || 0;
          let maxPP = MoveDB[moveName] ? MoveDB[moveName].pp : 0;
          if (currentPP < maxPP) {
            moveToRestore = moveName;
            break;
          }
        }
        
        if (!moveToRestore) {
          logToBattle(`${digimon.name}'s moves are already at full PP!`);
          return;
        }
        
        let currentPP = digimon.movePP[moveToRestore] || 0;
        let maxPP = MoveDB[moveToRestore] ? MoveDB[moveToRestore].pp : 0;
        let restored = maxPP - currentPP;
        digimon.movePP[moveToRestore] = maxPP;
        
        logToBattle(`Used ${itemName} on ${digimon.name}. Fully restored PP to ${moveToRestore}!`);
        used = true;
        updateBattleUI();
      }

      if (itemName === "Elixir") {
        let digimon = gameState.party[activePlayerDigimonIndex];
        if (!digimon) return;
        
        let anyRestored = false;
        let totalRestored = 0;
        
        digimon.moves.forEach(moveName => {
          let currentPP = digimon.movePP[moveName] || 0;
          let maxPP = MoveDB[moveName] ? MoveDB[moveName].pp : 0;
          if (currentPP < maxPP) {
            let restored = Math.min(10, maxPP - currentPP);
            digimon.movePP[moveName] = Math.min(maxPP, currentPP + 10);
            totalRestored += restored;
            anyRestored = true;
          }
        });
        
        if (!anyRestored) {
          logToBattle(`${digimon.name}'s moves are already at full PP!`);
          return;
        }
        
        logToBattle(`Used ${itemName} on ${digimon.name}. Restored ${totalRestored} total PP to all moves!`);
        used = true;
        updateBattleUI();
      }

      if (itemName === "Max Elixir") {
        let digimon = gameState.party[activePlayerDigimonIndex];
        if (!digimon) return;
        
        let anyRestored = false;
        
        digimon.moves.forEach(moveName => {
          let currentPP = digimon.movePP[moveName] || 0;
          let maxPP = MoveDB[moveName] ? MoveDB[moveName].pp : 0;
          if (currentPP < maxPP) {
            digimon.movePP[moveName] = maxPP;
            anyRestored = true;
          }
        });
        
        if (!anyRestored) {
          logToBattle(`${digimon.name}'s moves are already at full PP!`);
          return;
        }
        
        logToBattle(`Used ${itemName} on ${digimon.name}. Fully restored PP to all moves!`);
        used = true;
        updateBattleUI();
      }
      
      // Evolution items handled elsewhere
      
      if (used) {
        gameState.inventory[itemName]--;
        closeItemOverlay();
        
        // Enemy's turn after using item
        enemyAction();
      }
    }

    /* N. MOVE LEARN OVERLAY */
    let pendingLearnDigimon = null;
    let pendingMoveName = null;

    function openMoveLearnOverlay(digimon, newMove) {
      pendingLearnDigimon = digimon;
      pendingMoveName = newMove;
      
      document.getElementById("learn-move-description").innerText = `
        ${digimon.name} wants to learn ${newMove}. Select a move to forget:
      `;
      
      let currentMovesContainer = document.getElementById("current-moves");
      currentMovesContainer.innerHTML = "";
      
      digimon.moves.forEach((moveName, i) => {
        let move = MoveDB[moveName];
        if (!move) return;
        
        let moveDiv = document.createElement("div");
        moveDiv.className = "current-move";
        moveDiv.onclick = () => replaceMoveConfirm(i);
        
        moveDiv.innerHTML = `
          <div class="move-header">
            <span class="move-name">${moveName}</span>
            <span class="move-type type-${move.type.toLowerCase()}">${move.type}</span>
          </div>
          <p class="move-description">${move.description || ""}</p>
        `;
        
        currentMovesContainer.appendChild(moveDiv);
      });
      
      // Display new move info
      let newMoveInfo = MoveDB[newMove];
      if (newMoveInfo) {
        document.getElementById("new-move").innerHTML = `
          <div class="move-header">
            <span class="move-name">${newMove}</span>
            <span class="move-type type-${newMoveInfo.type.toLowerCase()}">${newMoveInfo.type}</span>
          </div>
          <p class="move-description">${newMoveInfo.description || ""}</p>
        `;
      } else {
        document.getElementById("new-move").innerText = `New Move: ${newMove}`;
      }
      
      document.getElementById("move-learn-overlay").style.display = "flex";
    }

    function closeMoveLearnOverlay() {
      document.getElementById("move-learn-overlay").style.display = "none";
      pendingLearnDigimon = null;
      pendingMoveName = null;
    }

    function replaceMoveConfirm(index) {
      if (!pendingLearnDigimon || !pendingMoveName) return;
      
      if (index >= 0) {
        // Replace the selected move
        let oldMove = pendingLearnDigimon.moves[index];
        pendingLearnDigimon.moves[index] = pendingMoveName;
        
        // Remove old move's PP and add new move's PP
        if (oldMove && pendingLearnDigimon.movePP[oldMove] !== undefined) {
          delete pendingLearnDigimon.movePP[oldMove];
        }
        
        let moveData = MoveDB[pendingMoveName];
        if (moveData) {
          pendingLearnDigimon.movePP[pendingMoveName] = moveData.pp;
        }
        
        logToBattle(`${pendingLearnDigimon.name} learned ${pendingMoveName}!`);
      } else {
        // Skip learning the new move
        logToBattle(`${pendingLearnDigimon.name} did not learn ${pendingMoveName}.`);
      }
      
      closeMoveLearnOverlay();
    }

    // Helper function to restore all PP for a Digimon
    function restoreAllPP(digimon) {
      digimon.moves.forEach(moveName => {
        let moveData = MoveDB[moveName];
        if (moveData) {
          digimon.movePP[moveName] = moveData.pp;
        }
      });
    }

    // Abilities system
    function applyAbilities(digimon, situation, target = null) {
      if (!digimon.abilities) return;
      
      digimon.abilities.forEach(abilityName => {
        switch (abilityName) {
          case "Vitality":
            if (situation === "levelUp") {
              // Vitality gives extra HP on level up
              let bonus = Math.floor(digimon.baseStats.HP * 0.1);
              digimon.baseStats.HP += bonus;
              digimon.currentStats.HP += bonus;
              digimon.currentHP += bonus;
              logToBattle(`Vitality: ${digimon.name} gained extra HP!`);
            }
            break;
            
          case "Courage Boost":
            if (situation === "battleStart") {
              // Courage Boost increases ATK at start of battle
              let boost = Math.floor(digimon.baseStats.ATK * 0.2);
              digimon.currentStats.ATK += boost;
              logToBattle(`Courage Boost: ${digimon.name}'s ATK rose!`);
            }
            break;
            
          case "Friendship Bond":
            if (situation === "lowHP" && digimon.currentHP < digimon.currentStats.HP * 0.3) {
              // Friendship Bond boosts all stats when at low HP
              for (let stat of ["ATK", "DEF", "SATK", "SDEF", "SPD"]) {
                digimon.currentStats[stat] = Math.floor(digimon.currentStats[stat] * 1.1);
              }
              logToBattle(`Friendship Bond: ${digimon.name}'s bond strengthened!`);
            }
            break;
            
          case "Sincerity":
            if (situation === "statusInflicted") {
              // Sincerity has chance to cure status effects
              if (Math.random() < 0.3) {
                digimon.status = null;
                logToBattle(`Sincerity: ${digimon.name} overcame the status effect!`);
              }
            }
            break;
            
          case "Reliability":
            if (situation === "battleStart") {
              // Reliability boosts DEF and S.DEF
              digimon.currentStats.DEF = Math.floor(digimon.currentStats.DEF * 1.15);
              digimon.currentStats.SDEF = Math.floor(digimon.currentStats.SDEF * 1.15);
              logToBattle(`Reliability: ${digimon.name}'s defenses rose!`);
            }
            break;
            
          case "Hope":
            if (situation === "criticalHit") {
              // Hope reduces critical hit damage
              return 0.5; // Return damage multiplier
            }
            break;
            
          case "Diamond Storm":
            if (situation === "attack" && target) {
              // Diamond Storm has chance to boost S.ATK on attack
              if (Math.random() < 0.2) {
                digimon.currentStats.SATK = Math.floor(digimon.currentStats.SATK * 1.1);
                logToBattle(`Diamond Storm: ${digimon.name}'s S.ATK rose!`);
              }
            }
            break;
            
          case "Endurance":
            if (situation === "faint") {
              // Endurance gives chance to survive with 1 HP
              if (Math.random() < 0.1) {
                digimon.currentHP = 1;
                logToBattle(`Endurance: ${digimon.name} endured the hit!`);
                return true; // Survived
              }
            }
            break;
            
          case "Growth":
            if (situation === "expGain") {
              // Growth increases EXP gained
              return 1.2; // 20% more EXP
            }
            break;
            
          case "Stealth":
            if (situation === "battleStart") {
              // Stealth boosts SPD and evasion
              digimon.currentStats.SPD = Math.floor(digimon.currentStats.SPD * 1.3);
              logToBattle(`Stealth: ${digimon.name}'s speed rose sharply!`);
            }
            break;
            
          case "Float":
            if (situation === "groundMove") {
              // Float makes immune to ground-type moves
              logToBattle(`Float: ${digimon.name} floated above the attack!`);
              return 0; // No damage
            }
            break;
            
          case "Swim":
            if (situation === "battleStart") {
              // Swim boosts water-type move power
              logToBattle(`Swim: ${digimon.name} is ready for aquatic combat!`);
            }
            break;
            
          case "Burning Courage":
            if (situation === "lowHP" && digimon.currentHP < digimon.currentStats.HP * 0.25) {
              // Burning Courage drastically boosts ATK when HP is very low
              digimon.currentStats.ATK = Math.floor(digimon.currentStats.ATK * 1.5);
              logToBattle(`Burning Courage: ${digimon.name}'s courage is burning bright!`);
            }
            break;
            
          case "Ice Claws":
            if (situation === "attack" && target) {
              // Ice Claws have chance to freeze target
              if (Math.random() < 0.15) {
                target.status = "frozen";
                logToBattle(`Ice Claws: ${target.name} was frozen!`);
              }
            }
            break;
            
          case "Mystic Fire":
            if (situation === "attack" && target) {
              // Mystic Fire has chance to burn target
              if (Math.random() < 0.15) {
                target.status = "burned";
                logToBattle(`Mystic Fire: ${target.name} was burned!`);
              }
            }
            break;
        }
      });
    }

    /* O. DIGICRYSTAL SHOP */
    function openDigiCrystalShop() {
      document.getElementById("main-menu").style.display = "none";
      document.getElementById("digicrystal-shop-panel").style.display = "flex";
      document.getElementById("meta-digicrystals-count").innerText = gameState.digicrystals;
      renderDigiCrystalUpgrades();
    }

    function closeDigiCrystalShop() {
      document.getElementById("digicrystal-shop-panel").style.display = "none";
      document.getElementById("main-menu").style.display = "flex";
    }

    function renderDigiCrystalUpgrades() {
      let container = document.getElementById("digicrystal-upgrades");
      container.innerHTML = "";
      
      // Create upgrade categories
      let categories = [
        {
          title: "Starter Digimon Unlocks",
          upgrades: [
            {id: "starter_agumon", name: "Unlock Agumon", description: "Unlocks Agumon as a starter option", cost: 1000, icon: "🔥"},
            {id: "starter_gabumon", name: "Unlock Gabumon", description: "Unlocks Gabumon as a starter option", cost: 1000, icon: "❄️"},
            {id: "starter_palmon", name: "Unlock Palmon", description: "Unlocks Palmon as a starter option", cost: 1000, icon: "🌿"},
            {id: "starter_gomamon", name: "Unlock Gomamon", description: "Unlocks Gomamon as a starter option", cost: 1000, icon: "💧"},
            {id: "starter_patamon", name: "Unlock Patamon", description: "Unlocks Patamon as a starter option", cost: 1000, icon: "✨"},
            {id: "starter_renamon", name: "Unlock Renamon", description: "Unlocks Renamon as a starter option", cost: 1000, icon: "🦊"}
          ]
        },
        {
          title: "Starter Abilities",
          upgrades: [
            {id: "ability2", name: "Second Ability", description: "Unlocks secondary ability for starters", cost: 500, icon: "⚡"},
            {id: "ability3", name: "Third Ability", description: "Unlocks tertiary ability for starters", cost: 1000, icon: "⚡⚡"}
          ]
        },
        {
          title: "Stat Boosts",
          upgrades: [
            {id: "starter_atk", name: "+5 ATK", description: "Permanent +5 ATK for starters", cost: 300, icon: "⚔️"},
            {id: "starter_def", name: "+5 DEF", description: "Permanent +5 DEF for starters", cost: 300, icon: "🛡️"},
            {id: "starter_satk", name: "+5 S.ATK", description: "Permanent +5 S.ATK for starters", cost: 300, icon: "🔮"},
            {id: "starter_sdef", name: "+5 S.DEF", description: "Permanent +5 S.DEF for starters", cost: 300, icon: "🧿"},
            {id: "starter_deatk", name: "+5 DE.ATK", description: "Permanent +5 DE.ATK for starters", cost: 300, icon: "🃏"},
            {id: "starter_dedef", name: "+5 DE.DEF", description: "Permanent +5 DE.DEF for starters", cost: 300, icon: "🔰"}
          ]
        },
        {
          title: "Game Upgrades",
          upgrades: [
            {id: "party_size", name: "Larger Party", description: "Increases max party size to 6", cost: 2000, icon: "👥"},
            {id: "additionalReward", name: "Extra Reward", description: "Get 1 additional reward option after battles", cost: 1500, icon: "🎁"},
            {id: "multipleRewards", name: "Multiple Rewards", description: "Can choose multiple rewards after battles", cost: 3000, icon: "🎁🎁"},
            {id: "startingCards", name: "Extra DE Cards", description: "Start each run with 8 random DE cards", cost: 1000, icon: "🃏"}
          ]
        }
      ];
      
      // Generate HTML for each category
      categories.forEach(category => {
        let categoryTitle = document.createElement("h3");
        categoryTitle.style.margin = "20px 0 10px";
        categoryTitle.textContent = category.title;
        container.appendChild(categoryTitle);
        
        let upgradesContainer = document.createElement("div");
        upgradesContainer.style.display = "flex";
        upgradesContainer.style.flexWrap = "wrap";
        upgradesContainer.style.justifyContent = "center";
        
        category.upgrades.forEach(upgrade => {
          let alreadyPurchased = gameState.permanentUpgrades[upgrade.id];
          
          let card = document.createElement("div");
          card.className = "upgrade-card";
          if (alreadyPurchased) card.style.opacity = "0.6";
          
          card.innerHTML = `
            <div class="upgrade-icon">${upgrade.icon || "🔄"}</div>
            <div class="upgrade-name">${upgrade.name}</div>
            <div class="upgrade-description">${upgrade.description}</div>
            <div class="upgrade-cost">${upgrade.cost} 💎</div>
            <button class="digimon-btn" ${alreadyPurchased ? 'disabled' : ''} onclick="buyDigiCrystalUpgrade('${upgrade.id}', ${upgrade.cost})">
              ${alreadyPurchased ? 'Purchased' : 'Buy'}
            </button>
          `;
          
          upgradesContainer.appendChild(card);
        });
        
        container.appendChild(upgradesContainer);
      });
    }

    function buyDigiCrystalUpgrade(id, cost) {
      if (gameState.digicrystals < cost) {
        alert("Not enough DigiCrystals!");
        return;
      }
      
      if (gameState.permanentUpgrades[id]) {
        alert("Already purchased!");
        return;
      }
      
      gameState.digicrystals -= cost;
      gameState.permanentUpgrades[id] = true;
      
      // Update display
      document.getElementById("meta-digicrystals-count").innerText = gameState.digicrystals;
      
      // Re-render upgrades
      renderDigiCrystalUpgrades();
      
      // Save global state
      saveGlobalState();
      
      alert(`Upgrade '${id}' purchased successfully!`);
    }

    /* P. DIGIVICE STORAGE */
    function openDigiviceStorage() {
      document.getElementById("main-menu").style.display = "none";
      document.getElementById("digivice-storage-panel").style.display = "flex";
      document.getElementById("storage-count").innerText = gameState.caughtDigimon.length;
      renderDigiviceStorage();
    }

    function closeDigiviceStorage() {
      document.getElementById("digivice-storage-panel").style.display = "none";
      document.getElementById("main-menu").style.display = "flex";
    }

    function renderDigiviceStorage() {
      let container = document.getElementById("storage-digimon-grid");
      container.innerHTML = "";
      
      // Update filter buttons
      document.querySelectorAll("#variant-filters button").forEach(btn => {
        btn.classList.remove("filter-active");
        
        let btnVariant = btn.textContent;
        if (btnVariant === currentVariantFilter) {
          btn.classList.add("filter-active");
        }
      });
      
      if (gameState.caughtDigimon.length === 0) {
        container.innerHTML = "<p>You haven't caught any Digimon yet!</p>";
        return;
      }
      
      // Filter by variant
      let filtered = gameState.caughtDigimon;
      if (currentVariantFilter !== "All") {
        filtered = gameState.caughtDigimon.filter(d => d.variant === currentVariantFilter);
      }
      
      if (filtered.length === 0) {
        container.innerHTML = `<p>No ${currentVariantFilter} Digimon caught yet!</p>`;
        return;
      }
      
      // Render each caught Digimon
      filtered.forEach(digimon => {
        let card = document.createElement("div");
        card.className = "caught-digi-card";
        
        let variantClass = `variant-${digimon.variant.toLowerCase()}`;
        
        card.innerHTML = `
          <div class="caught-digi-header">
            <div class="caught-digi-sprite" style="background-image: url(${digimon.spriteUrl})"></div>
            <div class="caught-digi-info">
              <div class="caught-digi-name">${digimon.name}</div>
              <div class="caught-digi-id">ID #${digimon.uniqueID}</div>
            </div>
          </div>
          <div class="caught-digi-details">
            <p>
              <span class="caught-digi-label">Variant:</span>
              <span class="caught-digi-value ${variantClass}">${digimon.variant}</span>
            </p>
            <p>
              <span class="caught-digi-label">Stage:</span>
              <span class="caught-digi-value">${digimon.stage}</span>
            </p>
            <p>
              <span class="caught-digi-label">Type:</span>
              <span class="caught-digi-value">${digimon.type}</span>
            </p>
            <p>
              <span class="caught-digi-label">Level:</span>
              <span class="caught-digi-value">${digimon.level}</span>
            </p>
          </div>
        `;
        
        container.appendChild(card);
      });
    }

    function setVariantFilter(variant) {
      currentVariantFilter = variant;
      renderDigiviceStorage();
    }

    function sortCaughtDigimon(mode) {
      switch (mode) {
        case "id":
          gameState.caughtDigimon.sort((a, b) => a.uniqueID - b.uniqueID);
          break;
        case "name":
          gameState.caughtDigimon.sort((a, b) => a.name.localeCompare(b.name));
          break;
        case "stage":
          const stageOrder = {"Fresh": 0, "In-Training": 1, "Rookie": 2, "Champion": 3, "Ultimate": 4, "Mega": 5};
          gameState.caughtDigimon.sort((a, b) => stageOrder[a.stage] - stageOrder[b.stage]);
          break;
        case "level":
          gameState.caughtDigimon.sort((a, b) => b.level - a.level);
          break;
      }
      
      renderDigiviceStorage();
    }

    /* Q. BATTLE ARENA PLACEHOLDER */
    function openBattleArena() {
      document.getElementById("main-menu").style.display = "none";
      document.getElementById("battle-arena-panel").style.display = "flex";
    }

    function closeBattleArena() {
      document.getElementById("battle-arena-panel").style.display = "none";
      document.getElementById("main-menu").style.display = "flex";
    }

    /* R. DIGIVICE SELECTION */
    function renderDigiviceSelection() {
      let container = document.getElementById("digivice-selection");
      container.innerHTML = "";
      
      // Available digivices
      let knownDigivices = [
        { id: "Original", name: "Original Digivice", description: "Boosts all stats by 5%" },
        { id: "D3", name: "D3 Digivice", description: "Increases EXP gain and variant rate" },
        { id: "D-ARK", name: "D-ARK Digivice", description: "20% chance for DE cards after turns" }
      ];
      
      // Render available digivices
      knownDigivices.forEach(digivice => {
        let level = gameState.digiviceLevels[digivice.id] || 1;
        
        let div = document.createElement("div");
        div.className = "digivice-option";
        
        if (gameState.activeDigivice === digivice.id) {
          div.classList.add("selected");
        }
        
        div.innerHTML = `
          <h4>${digivice.name}</h4>
          <p>Lv. ${level}</p>
          <p>${digivice.description}</p>
        `;
        
        div.onclick = () => selectDigivice(digivice.id);
        
        container.appendChild(div);
      });
      
      // Placeholder locked digivices
      for (let i = 1; i <= 3; i++) {
        let div = document.createElement("div");
        div.className = "digivice-option locked";
        div.innerHTML = `
          <h4>??? Digivice</h4>
          <p>Locked</p>
        `;
        container.appendChild(div);
      }
    }

    function selectDigivice(id) {
      gameState.activeDigivice = id;
      
      // Update selection visualization
      document.querySelectorAll(".digivice-option").forEach(option => {
        option.classList.remove("selected");
        
        if (option.querySelector("h4").textContent.includes(id)) {
          option.classList.add("selected");
        }
      });
    }

    /* S. RENDER STARTER DIGIMON */
    function renderStarterDigimon() {
      let container = document.getElementById("starter-digimon-grid");
      container.innerHTML = "";
      
      // List of starter Digimon
      let starters = [
        {name: "Agumon", unlockId: "starter_agumon"},
        {name: "Gabumon", unlockId: "starter_gabumon"},
        {name: "Palmon", unlockId: "starter_palmon"},
        {name: "Gomamon", unlockId: "starter_gomamon"},
        {name: "Patamon", unlockId: "starter_patamon"},
        {name: "Renamon", unlockId: "starter_renamon"}
      ];
      
      starters.forEach(starter => {
        let digimon = DigimonDB[starter.name];
        if (!digimon) return;
        
        let isLocked = false;
        
        // Check if this starter is locked (except Agumon which is always available)
        if (starter.name !== "Agumon" && !gameState.permanentUpgrades[starter.unlockId]) {
          isLocked = true;
        }
        
        let div = document.createElement("div");
        div.className = "digimon-starter-card";
        
        if (isLocked) {
          div.classList.add("locked");
        }
        
        div.setAttribute("data-name", starter.name);
        
        div.innerHTML = `
          <img src="${digimon.spriteUrl}" alt="${starter.name}">
          <p>${starter.name}</p>
          <div class="type type-${digimon.type.toLowerCase()}">${digimon.type}</div>
        `;
        
        if (!isLocked) {
          div.onclick = () => {
            div.classList.toggle("selected");
          };
        }
        
        container.appendChild(div);
      });
    }

    /* T. HELPER UTILS */
    function logToBattle(msg) {
      let log = document.getElementById("battle-log");
      if (!log) return;
      
      let p = document.createElement("p");
      
      // Add class for coloring different types of messages
      if (msg.includes("defeated") || msg.includes("knocked out")) {
        p.className = "log-damage";
      } else if (msg.includes("healed") || msg.includes("recovered")) {
        p.className = "log-heal";
      } else if (msg.includes("used")) {
        p.className = "log-attack";
      }
      
      p.innerHTML = msg;
      log.appendChild(p);
      log.scrollTop = log.scrollHeight;
    }

    function calculateLuck() {
      let luck = 0;
      
      // Base luck
      luck += 5;
      
      // Digivice bonus
      if (gameState.activeDigivice === "D3") {
        luck += gameState.digiviceLevels["D3"] * 2;
      }
      
      // Permanent upgrades
      if (gameState.permanentUpgrades.luckBoost) {
        luck += 10;
      }
      
      return luck;
    }

    /* U. DIGIMON & MOVE DATABASES */
    // Only partially shown for brevity
    const DigimonDB = {
      /* AGUMON LINE */
      "Botamon": {
        name: "Botamon",
        stage: "Fresh",
        type: "Data",
        baseStats: {HP: 20, ATK: 5, DEF: 4, SATK: 5, SDEF: 4, DEATK: 3, DEDEF: 3, SPD: 5},
        learnset: [{level: 1, move: "Bubble"}],
        nextEvo: {level: 3, target: "Koromon"},
        abilities: ["Vitality"],
        spriteUrl: "https://digimon.shadowsmith.com/img/botamon.jpg"
      },
      "Koromon": {
        name: "Koromon",
        stage: "In-Training",
        type: "Data",
        baseStats: {HP: 25, ATK: 7, DEF: 5, SATK: 7, SDEF: 5, DEATK: 4, DEDEF: 4, SPD: 5},
        learnset: [
          {level: 1, move: "Bubble"},
          {level: 3, move: "Bite"}
        ],
        nextEvo: {level: 5, target: "Agumon"},
        abilities: ["Vitality"],
        spriteUrl: "https://digimon.shadowsmith.com/img/koromon.jpg"
      },
      "Agumon": {
        name: "Agumon",
        stage: "Rookie",
        type: "Data",
        baseStats: {HP: 40, ATK: 14, DEF: 10, SATK: 12, SDEF: 10, DEATK: 10, DEDEF: 10, SPD: 12},
        learnset: [
          {level: 1, move: "Scratch"},
          {level: 3, move: "Bite"},
          {level: 7, move: "Data Blast"},
          {level: 10, move: "Data Boost"},
          {level: 15, move: "Precise Strike"},
          {level: 20, move: "Digital Surge"},
          {level: 25, move: "Data Repair"},
          {level: 30, move: "Mega Claw"},
          {level: 35, move: "Data Crush"}
        ],
        nextEvo: {level: 15, target: "Greymon"},
        abilities: ["Courage Boost"],
        spriteUrl: "https://digimon.shadowsmith.com/img/agumon.jpg"
      },
      "Greymon": {
        name: "Greymon",
        stage: "Champion",
        type: "Data",
        baseStats: {HP: 60, ATK: 25, DEF: 17, SATK: 18, SDEF: 15, DEATK: 15, DEDEF: 15, SPD: 16},
        learnset: [
          {level: 1, move: "Scratch"},
          {level: 3, move: "Bite"},
          {level: 7, move: "Data Blast"},
          {level: 10, move: "Data Boost"},
          {level: 15, move: "Precise Strike"},
          {level: 20, move: "Digital Surge"},
          {level: 25, move: "Data Repair"},
          {level: 30, move: "Mega Claw"},
          {level: 35, move: "Data Crush"},
          {level: 40, move: "Hybrid Slash"},
          {level: 45, move: "Giga Blast"}
        ],
        nextEvo: {
          branches: [
            {name: "MetalGreymon (Data)", level: 30, target: "MetalGreymonData"},
            {name: "SkullGreymon", item: "Dark Core", target: "SkullGreymon"},
            {name: "MetalGreymon (Virus)", item: "Virus Booster", target: "MetalGreymonVirus"}
          ]
        },
        abilities: ["Burning Courage"],
        spriteUrl: "https://digimon.shadowsmith.com/img/greymon.jpg"
      },
      
      /* GABUMON LINE */
      "Punimon": {
        name: "Punimon",
        stage: "Fresh",
        type: "Data",
        baseStats: {HP: 20, ATK: 5, DEF: 4, SATK: 5, SDEF: 4, DEATK: 3, DEDEF: 3, SPD: 5},
        learnset: [{level: 1, move: "Bubble"}],
        nextEvo: {level: 3, target: "Tsunomon"},
        abilities: ["Endurance"],
        spriteUrl: "https://digimon.shadowsmith.com/img/punimon.jpg"
      },
      "Tsunomon": {
        name: "Tsunomon",
        stage: "In-Training",
        type: "Data",
        baseStats: {HP: 25, ATK: 7, DEF: 6, SATK: 6, SDEF: 5, DEATK: 4, DEDEF: 4, SPD: 6},
        learnset: [
          {level: 1, move: "Bubble"},
          {level: 3, move: "Tackle"}
        ],
        nextEvo: {level: 5, target: "Gabumon"},
        abilities: ["Endurance"],
        spriteUrl: "https://digimon.shadowsmith.com/img/tsunomon.jpg"
      },
      "Gabumon": {
        name: "Gabumon",
        stage: "Rookie",
        type: "Vaccine",
        baseStats: {HP: 40, ATK: 12, DEF: 12, SATK: 14, SDEF: 12, DEATK: 10, DEDEF: 10, SPD: 12},
        learnset: [
          {level: 1, move: "Tackle"},
          {level: 3, move: "Claw"},
          {level: 7, move: "Holy Light"},
          {level: 10, move: "Vaccine Shield"},
          {level: 15, move: "Divine Strike"},
          {level: 20, move: "Holy Burst"},
          {level: 25, move: "Purify"},
          {level: 30, move: "Sacred Sword"},
          {level: 35, move: "Heavenly Blast"}
        ],
        nextEvo: {level: 15, target: "Garurumon"},
        abilities: ["Friendship Bond"],
        spriteUrl: "https://digimon.shadowsmith.com/img/gabumon.jpg"
      },
      
      /* PALMON LINE */
      "Yuramon": {
        name: "Yuramon",
        stage: "Fresh",
        type: "Data",
        baseStats: {HP: 20, ATK: 4, DEF: 4, SATK: 5, SDEF: 4, DEATK: 3, DEDEF: 3, SPD: 5},
        learnset: [{level: 1, move: "Bubble"}],
        nextEvo: {level: 3, target: "Tanemon"},
        abilities: ["Growth"],
        spriteUrl: "https://digimon.shadowsmith.com/img/yuramon.jpg"
      },
      "Tanemon": {
        name: "Tanemon",
        stage: "In-Training",
        type: "Data",
        baseStats: {HP: 22, ATK: 5, DEF: 4, SATK: 6, SDEF: 4, DEATK: 4, DEDEF: 4, SPD: 5},
        learnset: [
          {level: 1, move: "Bubble"},
          {level: 3, move: "Data Blast"}
        ],
        nextEvo: {level: 5, target: "Palmon"},
        abilities: ["Growth"],
        spriteUrl: "https://digimon.shadowsmith.com/img/tanemon.jpg"
      },
      "Palmon": {
        name: "Palmon",
        stage: "Rookie",
        type: "Data",
        baseStats: {HP: 38, ATK: 10, DEF: 10, SATK: 14, SDEF: 10, DEATK: 8, DEDEF: 8, SPD: 10},
        learnset: [
          {level: 1, move: "Data Blast"},
          {level: 3, move: "Scratch"},
          {level: 7, move: "Data Boost"},
          {level: 10, move: "Digital Surge"},
          {level: 15, move: "Data Repair"},
          {level: 20, move: "Precise Strike"},
          {level: 25, move: "Digital Barrier"},
          {level: 30, move: "Giga Blast"},
          {level: 35, move: "Data Crush"}
        ],
        nextEvo: {level: 15, target: "Togemon"},
        abilities: ["Sincerity"],
        spriteUrl: "https://digimon.shadowsmith.com/img/palmon.jpg"
      },
      
      /* GOMAMON LINE */
      "Pichimon": {
        name: "Pichimon",
        stage: "Fresh",
        type: "Data",
        baseStats: {HP: 20, ATK: 4, DEF: 4, SATK: 5, SDEF: 4, DEATK: 3, DEDEF: 3, SPD: 5},
        learnset: [{level: 1, move: "Bubble"}],
        nextEvo: {level: 3, target: "Bukamon"},
        abilities: ["Swim"],
        spriteUrl: "https://digimon.shadowsmith.com/img/pichimon.jpg"
      },
      "Bukamon": {
        name: "Bukamon",
        stage: "In-Training",
        type: "Data",
        baseStats: {HP: 24, ATK: 5, DEF: 4, SATK: 6, SDEF: 4, DEATK: 4, DEDEF: 4, SPD: 5},
        learnset: [
          {level: 1, move: "Bubble"},
          {level: 3, move: "Tackle"}
        ],
        nextEvo: {level: 5, target: "Gomamon"},
        abilities: ["Swim"],
        spriteUrl: "https://digimon.shadowsmith.com/img/bukamon.jpg"
      },
      "Gomamon": {
        name: "Gomamon",
        stage: "Rookie",
        type: "Vaccine",
        baseStats: {HP: 42, ATK: 10, DEF: 10, SATK: 12, SDEF: 10, DEATK: 8, DEDEF: 8, SPD: 10},
        learnset: [
          {level: 1, move: "Tackle"},
          {level: 3, move: "Air Shot"},
          {level: 7, move: "Vaccine Shield"},
          {level: 10, move: "Holy Burst"},
          {level: 15, move: "Purify"},
          {level: 20, move: "Divine Strike"},
          {level: 25, move: "Vaccine Analysis"},
          {level: 30, move: "Sacred Sword"},
          {level: 35, move: "Heavenly Blast"}
        ],
        nextEvo: {level: 15, target: "Ikkakumon"},
        abilities: ["Reliability"],
        spriteUrl: "https://digimon.shadowsmith.com/img/gomamon.jpg"
      },
      
      /* PATAMON LINE */
      "Poyomon": {
        name: "Poyomon",
        stage: "Fresh",
        type: "Data",
        baseStats: {HP: 20, ATK: 4, DEF: 4, SATK: 5, SDEF: 4, DEATK: 3, DEDEF: 3, SPD: 5},
        learnset: [{level: 1, move: "Bubble"}],
        nextEvo: {level: 3, target: "Tokomon"},
        abilities: ["Float"],
        spriteUrl: "https://digimon.shadowsmith.com/img/poyomon.jpg"
      },
      "Tokomon": {
        name: "Tokomon",
        stage: "In-Training",
        type: "Data",
        baseStats: {HP: 22, ATK: 5, DEF: 4, SATK: 6, SDEF: 4, DEATK: 4, DEDEF: 4, SPD: 5},
        learnset: [
          {level: 1, move: "Bubble"},
          {level: 3, move: "Air Shot"}
        ],
        nextEvo: {level: 5, target: "Patamon"},
        abilities: ["Float"],
        spriteUrl: "https://digimon.shadowsmith.com/img/tokomon.jpg"
      },
      "Patamon": {
        name: "Patamon",
        stage: "Rookie",
        type: "Vaccine",
        baseStats: {HP: 38, ATK: 10, DEF: 8, SATK: 14, SDEF: 10, DEATK: 8, DEDEF: 8, SPD: 12},
        learnset: [
          {level: 1, move: "Air Shot"},
          {level: 3, move: "Tackle"},
          {level: 7, move: "Holy Light"},
          {level: 10, move: "Vaccine Shield"},
          {level: 15, move: "Holy Burst"},
          {level: 20, move: "Purify"},
          {level: 25, move: "Divine Strike"},
          {level: 30, move: "Heavenly Blast"},
          {level: 35, move: "Vaccine Analysis"}
        ],
        nextEvo: {level: 15, target: "Angemon"},
        abilities: ["Hope"],
        spriteUrl: "https://digimon.shadowsmith.com/img/patamon.jpg"
      },
      
      /* RENAMON LINE */
      "Reremon": {
        name: "Reremon",
        stage: "Fresh",
        type: "Data",
        baseStats: {HP: 20, ATK: 4, DEF: 4, SATK: 5, SDEF: 4, DEATK: 4, DEDEF: 4, SPD: 5},
        learnset: [{level: 1, move: "Bubble"}],
        nextEvo: {level: 3, target: "Viximon"},
        abilities: ["Stealth"],
        spriteUrl: "https://digimon.shadowsmith.com/img/reremon.jpg"
      },
      "Viximon": {
        name: "Viximon",
        stage: "In-Training",
        type: "Data",
        baseStats: {HP: 22, ATK: 5, DEF: 4, SATK: 6, SDEF: 4, DEATK: 5, DEDEF: 5, SPD: 6},
        learnset: [
          {level: 1, move: "Bubble"},
          {level: 3, move: "Data Blast"}
        ],
        nextEvo: {level: 5, target: "Renamon"},
        abilities: ["Stealth"],
        spriteUrl: "https://digimon.shadowsmith.com/img/viximon.jpg"
      },
      "Renamon": {
        name: "Renamon",
        stage: "Rookie",
        type: "Data",
        baseStats: {HP: 35, ATK: 10, DEF: 9, SATK: 14, SDEF: 10, DEATK: 12, DEDEF: 10, SPD: 14},
        learnset: [
          {level: 1, move: "Data Blast"},
          {level: 3, move: "Scratch"},
          {level: 7, move: "Precise Strike"},
          {level: 10, move: "Digital Surge"},
          {level: 15, move: "Data Boost"},
          {level: 20, move: "Hybrid Slash"},
          {level: 25, move: "Data Repair"},
          {level: 30, move: "Mega Claw"},
          {level: 35, move: "Giga Blast"}
        ],
        nextEvo: {level: 15, target: "Kyubimon"},
        abilities: ["Diamond Storm"],
        spriteUrl: "https://digimon.shadowsmith.com/img/renamon.jpg"
      },

      /* CHAMPION STAGE EVOLUTIONS */
      "Garurumon": {
        name: "Garurumon",
        stage: "Champion", 
        type: "Vaccine",
        baseStats: {HP: 65, ATK: 20, DEF: 18, SATK: 22, SDEF: 20, DEATK: 16, DEDEF: 16, SPD: 20},
        learnset: [
          {level: 15, move: "Howling Blaster"},
          {level: 20, move: "Freeze Fang"},
          {level: 25, move: "Ice Wall"},
          {level: 30, move: "Subzero Ice Punch"},
          {level: 35, move: "Blizzard Breath"},
          {level: 40, move: "Absolute Zero"}
        ],
        nextEvo: {level: 30, target: "WereGarurumon"},
        abilities: ["Ice Claws"],
        spriteUrl: "https://digimon.shadowsmith.com/img/garurumon.jpg"
      },

      "Togemon": {
        name: "Togemon",
        stage: "Champion",
        type: "Data", 
        baseStats: {HP: 70, ATK: 18, DEF: 25, SATK: 15, SDEF: 22, DEATK: 12, DEDEF: 12, SPD: 10},
        learnset: [
          {level: 15, move: "Needle Spray"},
          {level: 20, move: "Coconut Punch"},
          {level: 25, move: "Thorn Whip"},
          {level: 30, move: "Poison Ivy"},
          {level: 35, move: "Gaia Force"},
          {level: 40, move: "Rose Spear"}
        ],
        nextEvo: {level: 30, target: "Lillymon"},
        abilities: ["Thorn Body"],
        spriteUrl: "https://digimon.shadowsmith.com/img/togemon.jpg"
      },

      "Ikkakumon": {
        name: "Ikkakumon",
        stage: "Champion",
        type: "Vaccine",
        baseStats: {HP: 75, ATK: 22, DEF: 20, SATK: 18, SDEF: 25, DEATK: 14, DEDEF: 14, SPD: 12},
        learnset: [
          {level: 15, move: "Harpoon Torpedo"},
          {level: 20, move: "Tusk Strike"},
          {level: 25, move: "Heat Top"},
          {level: 30, move: "Ice Cudgel"},
          {level: 35, move: "Aqua Magic"},
          {level: 40, move: "Glacier Bash"}
        ],
        nextEvo: {level: 30, target: "Zudomon"},
        abilities: ["Aqua Adaptation"],
        spriteUrl: "https://digimon.shadowsmith.com/img/ikkakumon.jpg"
      },

      "Angemon": {
        name: "Angemon", 
        stage: "Champion",
        type: "Vaccine",
        baseStats: {HP: 55, ATK: 18, DEF: 15, SATK: 28, SDEF: 25, DEATK: 20, DEDEF: 20, SPD: 18},
        learnset: [
          {level: 15, move: "Hand of Fate"},
          {level: 20, move: "Angel Rod"},
          {level: 25, move: "Heaven's Knuckle"},
          {level: 30, move: "Holy Disinfection"},
          {level: 35, move: "Divine Light"},
          {level: 40, move: "Sanctified Revival"}
        ],
        nextEvo: {level: 30, target: "MagnaAngemon"},
        abilities: ["Divine Protection"],
        spriteUrl: "https://digimon.shadowsmith.com/img/angemon.jpg"
      },

      "Kyubimon": {
        name: "Kyubimon",
        stage: "Champion", 
        type: "Data",
        baseStats: {HP: 50, ATK: 15, DEF: 12, SATK: 25, SDEF: 18, DEATK: 22, DEDEF: 18, SPD: 22},
        learnset: [
          {level: 15, move: "Fox Tail Inferno"},
          {level: 20, move: "Dragon Wheel"},
          {level: 25, move: "Mystical Fire"},
          {level: 30, move: "Will-O-Wisp"},
          {level: 35, move: "Spirit Fire"},
          {level: 40, move: "Dancing Flames"}
        ],
        nextEvo: {level: 30, target: "Taomon"},
        abilities: ["Mystic Fire"],
        spriteUrl: "https://digimon.shadowsmith.com/img/kyubimon.jpg"
      },

      /* ULTIMATE STAGE EVOLUTIONS */
      "MetalGreymonData": {
        name: "MetalGreymon",
        stage: "Ultimate",
        type: "Data",
        baseStats: {HP: 85, ATK: 35, DEF: 28, SATK: 30, SDEF: 25, DEATK: 25, DEDEF: 25, SPD: 22},
        learnset: [
          {level: 30, move: "Giga Destroyer"},
          {level: 35, move: "Metal Slash"},
          {level: 40, move: "Trident Arm"},
          {level: 45, move: "Cyber Launcher"},
          {level: 50, move: "Mechanical Rage"}
        ],
        nextEvo: {level: 50, target: "WarGreymon"},
        abilities: ["Mechanical Body"],
        spriteUrl: "https://digimon.shadowsmith.com/img/metalgreymon.jpg"
      },

      "WereGarurumon": {
        name: "WereGarurumon",
        stage: "Ultimate",
        type: "Vaccine", 
        baseStats: {HP: 80, ATK: 30, DEF: 25, SATK: 28, SDEF: 30, DEATK: 22, DEDEF: 22, SPD: 28},
        learnset: [
          {level: 30, move: "Wolf Claw"},
          {level: 35, move: "Garuru Kick"},
          {level: 40, move: "Freeze Fang"},
          {level: 45, move: "Ice Wall"},
          {level: 50, move: "Absolute Zero Storm"}
        ],
        nextEvo: {level: 50, target: "MetalGarurumon"},
        abilities: ["Beast Mode"],
        spriteUrl: "https://digimon.shadowsmith.com/img/weregarurumon.jpg"
      },

      "Lillymon": {
        name: "Lillymon",
        stage: "Ultimate",
        type: "Data",
        baseStats: {HP: 75, ATK: 25, DEF: 22, SATK: 35, SDEF: 30, DEATK: 18, DEDEF: 18, SPD: 25},
        learnset: [
          {level: 30, move: "Flower Cannon"},
          {level: 35, move: "Petal Dance"},
          {level: 40, move: "Thorn Whip"},
          {level: 45, move: "Flower Wreath"},
          {level: 50, move: "Sun-Crescent Kick"}
        ],
        nextEvo: {level: 50, target: "Rosemon"},
        abilities: ["Nature's Blessing"],
        spriteUrl: "https://digimon.shadowsmith.com/img/lillymon.jpg"
      },

      "Zudomon": {
        name: "Zudomon", 
        stage: "Ultimate",
        type: "Vaccine",
        baseStats: {HP: 90, ATK: 32, DEF: 30, SATK: 25, SDEF: 35, DEATK: 20, DEDEF: 20, SPD: 18},
        learnset: [
          {level: 30, move: "Vulcan's Hammer"},
          {level: 35, move: "Shell Slam"},
          {level: 40, move: "Horn Torpedo"},
          {level: 45, move: "Aqua Magic"},
          {level: 50, move: "Thunder Storm"}
        ],
        nextEvo: {level: 50, target: "Vikemon"},
        abilities: ["Shell Armor"],
        spriteUrl: "https://digimon.shadowsmith.com/img/zudomon.jpg"
      },

      "MagnaAngemon": {
        name: "MagnaAngemon",
        stage: "Ultimate", 
        type: "Vaccine",
        baseStats: {HP: 70, ATK: 25, DEF: 20, SATK: 40, SDEF: 35, DEATK: 30, DEDEF: 30, SPD: 25},
        learnset: [
          {level: 30, move: "Gate of Destiny"},
          {level: 35, move: "Magna Antidote"},
          {level: 40, move: "Soul Banish"},
          {level: 45, move: "Heaven's Gate"},
          {level: 50, move: "Final Excalibur"}
        ],
        nextEvo: {level: 50, target: "Seraphimon"},
        abilities: ["Holy Power"],
        spriteUrl: "https://digimon.shadowsmith.com/img/magnaangemon.jpg"
      },

      "Taomon": {
        name: "Taomon",
        stage: "Ultimate",
        type: "Data", 
        baseStats: {HP: 65, ATK: 20, DEF: 18, SATK: 38, SDEF: 32, DEATK: 35, DEDEF: 28, SPD: 30},
        learnset: [
          {level: 30, move: "Talisman of Light"},
          {level: 35, move: "Thousand Spells"},
          {level: 40, move: "Om Shanti"},
          {level: 45, move: "Brush Stroke"},
          {level: 50, move: "Trinity Burst"}
        ],
        nextEvo: {level: 50, target: "Sakuyamon"},
        abilities: ["Mystic Arts"],
        spriteUrl: "https://digimon.shadowsmith.com/img/taomon.jpg"
      },

      /* MEGA STAGE EVOLUTIONS */
      "WarGreymon": {
        name: "WarGreymon",
        stage: "Mega",
        type: "Data",
        baseStats: {HP: 100, ATK: 50, DEF: 40, SATK: 45, SDEF: 35, DEATK: 35, DEDEF: 35, SPD: 30},
        learnset: [
          {level: 50, move: "Terra Force"},
          {level: 55, move: "Dramon Killer"},
          {level: 60, move: "Great Tornado"},
          {level: 65, move: "Gaia Force"},
          {level: 70, move: "Brave Shield"}
        ],
        nextEvo: null,
        abilities: ["Dramon Destroyer"],
        spriteUrl: "https://digimon.shadowsmith.com/img/wargreymon.jpg"
      },

      "MetalGarurumon": {
        name: "MetalGarurumon", 
        stage: "Mega",
        type: "Vaccine",
        baseStats: {HP: 95, ATK: 40, DEF: 35, SATK: 50, SDEF: 45, DEATK: 30, DEDEF: 30, SPD: 40},
        learnset: [
          {level: 50, move: "Cocytus Breath"},
          {level: 55, move: "Ice Wolf Claw"},
          {level: 60, move: "Metal Wolf Claw"},
          {level: 65, move: "Garuru Tomahawk"},
          {level: 70, move: "Grace Cross Freezer"}
        ],
        nextEvo: null,
        abilities: ["Cyber Beast"],
        spriteUrl: "https://digimon.shadowsmith.com/img/metalgarurumon.jpg"
      }
      // Additional Mega forms can be added as needed
    };

    // Simplified MoveDB
    const MoveDB = {
      // Basic moves
      "Bubble": {type: "Data", power: 40, pp: 35, scale: "SATK", effect: null, description: "Bubbles strike the opponent"},
      "Bite": {type: "Virus", power: 45, pp: 30, scale: "ATK", effect: "flinch10", description: "Sharp fangs bite the opponent"},
      "Scratch": {type: "Data", power: 40, pp: 35, scale: "ATK", effect: null, description: "Basic physical attack"},
      "Tackle": {type: "Vaccine", power: 40, pp: 35, scale: "ATK", effect: null, description: "Body slam attack"},
      "Claw": {type: "Virus", power: 50, pp: 25, scale: "ATK", effect: null, description: "Sharp claws slash the opponent"},
      "Air Shot": {type: "Vaccine", power: 40, pp: 30, scale: "SATK", effect: null, description: "Concentrated air blast"},
      
      // Special/status moves
      "Data Blast": {type: "Data", power: 55, pp: 20, scale: "SATK", effect: null, description: "Concentrated data energy"},
      "Holy Light": {type: "Vaccine", power: 55, pp: 20, scale: "SATK", effect: null, description: "Purifying light energy"},
      "Virus Beam": {type: "Virus", power: 55, pp: 20, scale: "SATK", effect: null, description: "Malicious energy beam"},
      "Data Boost": {type: "Data", power: 0, pp: 10, scale: null, effect: "selfATKup selfSATKup", description: "Raises ATK & S.ATK"},
      "Vaccine Shield": {type: "Vaccine", power: 0, pp: 10, scale: null, effect: "selfDEFup selfSDEFup", description: "Raises DEF & S.DEF"},
      "Digital Surge": {type: "Data", power: 65, pp: 15, scale: "SATK", effect: null, description: "Surge of digital energy"},
      "Holy Burst": {type: "Vaccine", power: 65, pp: 15, scale: "SATK", effect: "satkUp15", description: "15% chance to boost S.ATK"},
      "Precise Strike": {type: "Data", power: 60, pp: 20, scale: "ATK", effect: "critUp", description: "Higher critical hit ratio"},
      "Data Repair": {type: "Data", power: 0, pp: 15, scale: null, effect: "heal40", description: "Heals 40% HP"},
      "Purify": {type: "Vaccine", power: 0, pp: 10, scale: null, effect: "clearStatuses", description: "Removes status effects"},
      
      // Advanced moves
      "Mega Claw": {type: "Data", power: 85, pp: 10, scale: "ATK", effect: null, description: "Powerful slashing attack"},
      "Giga Blast": {type: "Data", power: 85, pp: 10, scale: "SATK", effect: null, description: "Explosive data energy"},
      "Digital Barrier": {type: "Data", power: 0, pp: 10, scale: null, effect: "dmgReduce50_3", description: "Reduces damage for 3 turns"},
      "Data Crush": {type: "Data", power: 100, pp: 5, scale: "ATK", effect: "recoil25", description: "25% recoil damage"},
      "Divine Strike": {type: "Vaccine", power: 65, pp: 15, scale: "ATK", effect: null, description: "Holy-powered physical attack"},
      "Heavenly Blast": {type: "Vaccine", power: 85, pp: 10, scale: "SATK", effect: null, description: "Divine energy explosion"},
      "Divine Judgment": {type: "Vaccine", power: 100, pp: 5, scale: "SATK", effect: "skipNext", description: "Cannot attack next turn"},
      "Sacred Sword": {type: "Vaccine", power: 85, pp: 10, scale: "ATK", effect: null, description: "Holy blade attack"},
      
      // Status effects
      "Vaccine Analysis": {type: "Vaccine", power: 0, pp: 15, scale: null, effect: "scan", description: "Analyzes opponent's digital structure"},
      "Virus Infect": {type: "Virus", power: 0, pp: 10, scale: null, effect: "glitch75", description: "75% chance to cause Glitch status"},
      "Virus Override": {type: "Virus", power: 0, pp: 10, scale: null, effect: "stealBuffs", description: "Steals opponent's buffs"},
      "Virus Corruption": {type: "Virus", power: 0, pp: 10, scale: null, effect: "sdefDown", description: "Lowers opponent's S.DEF"},
      
      // More powerful moves
      "Hybrid Slash": {type: "Data", power: 65, pp: 15, scale: "ATK", effect: null, description: "Charged digital slash"},
      
      // Virus-specific moves
      "Darkness Claw": {type: "Virus", power: 70, pp: 15, scale: "ATK", effect: "defDown15", description: "15% chance to lower defense"},
      "Shadow Blast": {type: "Virus", power: 70, pp: 15, scale: "SATK", effect: "sdefDown15", description: "15% chance to lower S.DEF"},
      "Nightmare Slash": {type: "Virus", power: 90, pp: 10, scale: "ATK", effect: "glitch20", description: "20% chance to glitch"},
      "Desolation Beam": {type: "Virus", power: 90, pp: 10, scale: "SATK", effect: "randomStatDown2_20", description: "20% chance to lower 2 random stats"},
      "Virus Overload": {type: "Virus", power: 100, pp: 5, scale: "SATK", effect: "hpCost20", description: "User loses 20% HP"},
      "Dark Zone Collapse": {type: "Virus", power: 170, pp: 5, scale: "SATK", effect: "miss50", description: "50% chance to miss"},
      "Apocalypse Code": {type: "Virus", power: 160, pp: 5, scale: "SATK", effect: "skipNext", description: "Can't act next turn"},
      "Fatal Error": {type: "Virus", power: 140, pp: 5, scale: "SATK", effect: null, description: "Catastrophic virus attack"},
      
      // Special cards
      "Ultimate Ping": {type: "Data", power: 110, pp: 5, scale: "SATK", effect: "priority", description: "Always hits first"},
      "Nightmare Code": {type: "Virus", power: 100, pp: 10, scale: "SATK", effect: "glitch100", description: "Guarantees glitch status"},
      "Holy Cleanse": {type: "Vaccine", power: 70, pp: 15, scale: "SATK", effect: "clearNeg", description: "Removes negative statuses"},
      "Holy Encryption": {type: "Vaccine", power: 0, pp: 10, scale: "SATK", effect: "noDE3turns", description: "Blocks DE moves for 3 turns"},
      "Heavenly Code": {type: "Vaccine", power: 120, pp: 5, scale: "SATK", effect: "allStatsUp1_40", description: "40% chance to raise all stats"},
      "Digital Hazard": {type: "Data", power: 150, pp: 5, scale: "SATK", effect: "selfDamage30", description: "User loses 30% HP"},
      "Divine Protocol": {type: "Vaccine", power: 95, pp: 10, scale: "SATK", effect: "defUp", description: "Raises DEF"},
      "Chrome Digizoid": {type: "Vaccine", power: 130, pp: 5, scale: "SATK", effect: "defUp2 sdefUp2", description: "Raises DEF & S.DEF by 2 stages"},
      "Quantum Data": {type: "Data", power: 120, pp: 5, scale: "SATK", effect: "critUp", description: "High critical hit ratio"},

      // Champion+ exclusive moves
      "Howling Blaster": {type: "Vaccine", power: 70, pp: 15, scale: "SATK", effect: null, description: "Ice-cold howl attack"},
      "Freeze Fang": {type: "Vaccine", power: 65, pp: 20, scale: "ATK", effect: "freeze25", description: "25% chance to freeze"},
      "Ice Wall": {type: "Vaccine", power: 0, pp: 10, scale: null, effect: "selfDEFup2", description: "Raises DEF by 2 stages"},
      "Subzero Ice Punch": {type: "Vaccine", power: 80, pp: 10, scale: "ATK", effect: "freeze30", description: "30% chance to freeze"},
      "Blizzard Breath": {type: "Vaccine", power: 90, pp: 10, scale: "SATK", effect: "speedDown50", description: "50% chance to lower speed"},
      "Absolute Zero": {type: "Vaccine", power: 120, pp: 5, scale: "SATK", effect: "freeze50", description: "50% chance to freeze"},

      "Needle Spray": {type: "Data", power: 50, pp: 25, scale: "ATK", effect: "multiHit", description: "Hits 2-5 times"},
      "Coconut Punch": {type: "Data", power: 70, pp: 15, scale: "ATK", effect: null, description: "Powerful punch attack"},
      "Thorn Whip": {type: "Data", power: 60, pp: 20, scale: "ATK", effect: "poison20", description: "20% chance to poison"},
      "Poison Ivy": {type: "Data", power: 55, pp: 15, scale: "SATK", effect: "poison75", description: "75% chance to poison"},
      "Rose Spear": {type: "Data", power: 85, pp: 10, scale: "ATK", effect: "critUp", description: "High critical hit ratio"},

      "Harpoon Torpedo": {type: "Vaccine", power: 75, pp: 15, scale: "ATK", effect: null, description: "Piercing torpedo attack"},
      "Tusk Strike": {type: "Vaccine", power: 80, pp: 10, scale: "ATK", effect: "defDown25", description: "25% chance to lower defense"},
      "Heat Top": {type: "Vaccine", power: 70, pp: 15, scale: "SATK", effect: "burn30", description: "30% chance to burn"},
      "Ice Cudgel": {type: "Vaccine", power: 85, pp: 10, scale: "ATK", effect: "freeze20", description: "20% chance to freeze"},
      "Glacier Bash": {type: "Vaccine", power: 95, pp: 5, scale: "ATK", effect: "freeze40", description: "40% chance to freeze"},

      "Hand of Fate": {type: "Vaccine", power: 90, pp: 10, scale: "SATK", effect: null, description: "Divine judgment attack"},
      "Angel Rod": {type: "Vaccine", power: 75, pp: 15, scale: "ATK", effect: "heal15", description: "Heals 15% HP after use"},
      "Heaven's Knuckle": {type: "Vaccine", power: 80, pp: 10, scale: "ATK", effect: "critUp", description: "High critical hit ratio"},
      "Holy Disinfection": {type: "Vaccine", power: 0, pp: 15, scale: null, effect: "clearAllNeg", description: "Removes all negative effects"},
      "Divine Light": {type: "Vaccine", power: 100, pp: 5, scale: "SATK", effect: "allStatsUp1_30", description: "30% chance to raise all stats"},
      "Sanctified Revival": {type: "Vaccine", power: 0, pp: 5, scale: null, effect: "fullHeal", description: "Fully restores HP"},

      "Fox Tail Inferno": {type: "Data", power: 80, pp: 10, scale: "SATK", effect: "burn40", description: "40% chance to burn"},
      "Dragon Wheel": {type: "Data", power: 85, pp: 10, scale: "SATK", effect: null, description: "Spinning fire attack"},
      "Mystical Fire": {type: "Data", power: 75, pp: 15, scale: "SATK", effect: "satkUp25", description: "25% chance to boost S.ATK"},
      "Will-O-Wisp": {type: "Data", power: 60, pp: 20, scale: "SATK", effect: "burn60", description: "60% chance to burn"},
      "Spirit Fire": {type: "Data", power: 90, pp: 10, scale: "SATK", effect: "burn25", description: "25% chance to burn"},
      "Dancing Flames": {type: "Data", power: 110, pp: 5, scale: "SATK", effect: "multiHit", description: "Hits 2-4 times"},

      // Ultimate moves
      "Giga Destroyer": {type: "Data", power: 120, pp: 5, scale: "SATK", effect: "recoil33", description: "33% recoil damage"},
      "Metal Slash": {type: "Data", power: 90, pp: 10, scale: "ATK", effect: "defDown50", description: "50% chance to lower defense"},
      "Trident Arm": {type: "Data", power: 85, pp: 10, scale: "ATK", effect: "multiHit", description: "Hits 3 times"},
      "Cyber Launcher": {type: "Data", power: 100, pp: 8, scale: "SATK", effect: null, description: "High-tech projectile attack"},
      "Mechanical Rage": {type: "Data", power: 130, pp: 5, scale: "ATK", effect: "selfAtkUp2", description: "Raises ATK by 2 stages after use"},

      "Wolf Claw": {type: "Vaccine", power: 85, pp: 10, scale: "ATK", effect: "critUp", description: "High critical hit ratio"},
      "Garuru Kick": {type: "Vaccine", power: 90, pp: 10, scale: "ATK", effect: "speedUp50", description: "50% chance to boost speed"},
      "Absolute Zero Storm": {type: "Vaccine", power: 110, pp: 5, scale: "SATK", effect: "freeze75", description: "75% chance to freeze"},

      "Flower Cannon": {type: "Data", power: 95, pp: 8, scale: "SATK", effect: null, description: "Explosive flower projectile"},
      "Petal Dance": {type: "Data", power: 70, pp: 10, scale: "SATK", effect: "confusion50", description: "50% chance to confuse"},
      "Flower Wreath": {type: "Data", power: 0, pp: 10, scale: null, effect: "heal50", description: "Heals 50% HP"},
      "Sun-Crescent Kick": {type: "Data", power: 100, pp: 8, scale: "ATK", effect: "burn30", description: "30% chance to burn"},

      "Vulcan's Hammer": {type: "Vaccine", power: 100, pp: 8, scale: "ATK", effect: "stun30", description: "30% chance to stun"},
      "Shell Slam": {type: "Vaccine", power: 85, pp: 10, scale: "ATK", effect: "defUp25", description: "25% chance to raise defense"},
      "Horn Torpedo": {type: "Vaccine", power: 90, pp: 10, scale: "ATK", effect: "piercing", description: "Ignores defense bonuses"},
      "Thunder Storm": {type: "Vaccine", power: 110, pp: 5, scale: "SATK", effect: "paralysis50", description: "50% chance to paralyze"},

      "Gate of Destiny": {type: "Vaccine", power: 150, pp: 5, scale: "SATK", effect: "instaDeath20", description: "20% chance of instant KO"},
      "Magna Antidote": {type: "Vaccine", power: 0, pp: 10, scale: null, effect: "clearAllNeg fullHeal25", description: "Removes all status + 25% heal"},
      "Soul Banish": {type: "Vaccine", power: 120, pp: 5, scale: "SATK", effect: "exorcism", description: "Super effective vs Virus types"},
      "Heaven's Gate": {type: "Vaccine", power: 0, pp: 5, scale: null, effect: "invulnerable1turn", description: "Become invulnerable for 1 turn"},
      "Final Excalibur": {type: "Vaccine", power: 140, pp: 5, scale: "SATK", effect: "critUp", description: "Ultimate holy sword attack"},

      "Talisman of Light": {type: "Data", power: 85, pp: 10, scale: "SATK", effect: "sealMove1", description: "Seals one of opponent's moves"},
      "Thousand Spells": {type: "Data", power: 60, pp: 15, scale: "SATK", effect: "randomEffect", description: "Random magical effect"},
      "Om Shanti": {type: "Data", power: 0, pp: 10, scale: null, effect: "sleepAll", description: "Puts all combatants to sleep"},
      "Brush Stroke": {type: "Data", power: 90, pp: 8, scale: "SATK", effect: "sealAbility", description: "Seals opponent's ability"},
      "Trinity Burst": {type: "Data", power: 100, pp: 5, scale: "SATK", effect: "tripleType", description: "Hits with Data/Vaccine/Virus typing"},

      // Mega moves
      "Terra Force": {type: "Data", power: 150, pp: 5, scale: "SATK", effect: "earthShaker", description: "Ultimate earth attack"},
      "Dramon Killer": {type: "Data", power: 120, pp: 8, scale: "ATK", effect: "dragonSlayer", description: "Super effective vs Dragon-types"},
      "Great Tornado": {type: "Data", power: 110, pp: 8, scale: "SATK", effect: "windStorm", description: "Creates a devastating tornado"},
      "Brave Shield": {type: "Data", power: 0, pp: 8, scale: null, effect: "allStatsUp2", description: "Raises all stats by 2 stages"},

      "Cocytus Breath": {type: "Vaccine", power: 140, pp: 5, scale: "SATK", effect: "absoluteFreeze", description: "Ultimate ice attack"},
      "Ice Wolf Claw": {type: "Vaccine", power: 100, pp: 8, scale: "ATK", effect: "freeze60", description: "60% chance to freeze"},
      "Metal Wolf Claw": {type: "Vaccine", power: 110, pp: 8, scale: "ATK", effect: "defDown75", description: "75% chance to lower defense"},
      "Garuru Tomahawk": {type: "Vaccine", power: 120, pp: 5, scale: "ATK", effect: "critUp", description: "High critical hit ratio"},
      "Grace Cross Freezer": {type: "Vaccine", power: 160, pp: 5, scale: "SATK", effect: "freeze100", description: "Guaranteed freeze"}
    };

    // DE Cards Database
    const DECardsDB = [
      // Common (40% chance from rewards)
      {name: "Data Surge", type: "Data", basePower: 80, rarity: "Common", effect: null, description: "Basic data energy attack"},
      {name: "Virus Injection", type: "Virus", basePower: 80, rarity: "Common", effect: null, description: "Basic virus energy attack"},
      {name: "Vaccine Protocol", type: "Vaccine", basePower: 80, rarity: "Common", effect: null, description: "Basic vaccine energy attack"},
      {name: "Binary Blast", type: "Data", basePower: 70, rarity: "Common", effect: "speedUp50", description: "50% chance to boost Speed"},
      {name: "Corruption Wave", type: "Virus", basePower: 70, rarity: "Common", effect: "defDown50", description: "50% chance to lower DEF"},
      {name: "Holy Cleanse", type: "Vaccine", basePower: 70, rarity: "Common", effect: "clearNeg50", description: "50% chance to remove negative effects"},
      
      // Uncommon (30% chance from rewards)
      {name: "Fractal Force", type: "Data", basePower: 100, rarity: "Uncommon", effect: null, description: "Complex data energy attack"},
      {name: "Viral Evolution", type: "Virus", basePower: 95, rarity: "Uncommon", effect: "atkUp", description: "Increases ATK by one stage"},
      {name: "Digital Vaccine", type: "Vaccine", basePower: 90, rarity: "Uncommon", effect: "heal25", description: "Heals user by 25% HP"},
      {name: "Data Explosion", type: "Data", basePower: 110, rarity: "Uncommon", effect: "confusion50", description: "50% chance to cause confusion"},
      {name: "Nightmare Code", type: "Virus", basePower: 100, rarity: "Uncommon", effect: "glitch", description: "Causes Glitch status"},
      {name: "Divine Protocol", type: "Vaccine", basePower: 95, rarity: "Uncommon", effect: "defUp", description: "Raises DEF by one stage"},
      
      // Rare (20% chance from rewards)
      {name: "Quantum Data", type: "Data", basePower: 120, rarity: "Rare", effect: "critUp", description: "Increased critical hit ratio"},
      {name: "Virus Deletion", type: "Virus", basePower: 125, rarity: "Rare", effect: "sdefDown2_70", description: "70% chance to lower S.DEF by two stages"},
      {name: "Heavenly Code", type: "Vaccine", basePower: 120, rarity: "Rare", effect: "allStatsUp1_40", description: "40% chance to raise all stats"},
      {name: "Ultimate Ping", type: "Data", basePower: 110, rarity: "Rare", effect: "priority", description: "Always hits first"},
      {name: "Fatal Error", type: "Virus", basePower: 140, rarity: "Rare", effect: "selfDamage20", description: "User loses 20% HP"},
      {name: "Holy Encryption", type: "Vaccine", basePower: 115, rarity: "Rare", effect: "noDE3turns", description: "Opponent can't use DE for 3 turns"},
      
      // Very Rare (8% chance from rewards)
      {name: "Digital Hazard", type: "Data", basePower: 150, rarity: "VeryRare", effect: "selfDamage30", description: "User loses 30% HP"},
      {name: "Apocalypse Code", type: "Virus", basePower: 160, rarity: "VeryRare", effect: "skipNext", description: "User can't act next turn"},
      {name: "Digital Miracle", type: "Vaccine", basePower: 140, rarity: "VeryRare", effect: "heal50", description: "Heals user by 50% HP"},
      {name: "Zero Day Exploit", type: "Data", basePower: 130, rarity: "VeryRare", effect: "ignoreDefense", description: "Ignores DEF and S.DEF"},
      {name: "Dark Zone Collapse", type: "Virus", basePower: 170, rarity: "VeryRare", effect: "miss50", description: "50% chance to miss"},
      {name: "Chrome Digizoid", type: "Vaccine", basePower: 130, rarity: "VeryRare", effect: "defUp2 sdefUp2", description: "Raises DEF & S.DEF by 2 stages"},
      
      // Ultra Rare (2% chance from rewards)
      {name: "Chronodata Anomaly", type: "Data", basePower: 180, rarity: "UltraRare", effect: "doubleAttack50", description: "50% chance to attack twice"},
      {name: "Eternal Nightmare", type: "Virus", basePower: 190, rarity: "UltraRare", effect: "skipTwoTurns", description: "User skips two turns"},
      {name: "Divine Intervention", type: "Vaccine", basePower: 180, rarity: "UltraRare", effect: "fullHeal", description: "Fully heals user"},
      {name: "Fractal Corruption", type: "Data", basePower: 200, rarity: "UltraRare", effect: "selfHP1", description: "User's HP becomes 1"},
      {name: "Final Virus", type: "Virus", basePower: 220, rarity: "UltraRare", effect: "userFaints", description: "User faints after attack"},
      {name: "Absolute Vaccine", type: "Vaccine", basePower: 200, rarity: "UltraRare", effect: "maxStatsUp", description: "Maximizes all user's stats"}
    ];

    /* V. INITIALIZATION FUNCTIONS */
    // Title screen click handler
    document.getElementById("title-screen").addEventListener("click", function() {
      document.getElementById("title-screen").style.display = "none";
      document.getElementById("main-menu").style.display = "flex";
    });

    // Load saved game state on page load
    window.onload = function() {
      // Load global state
      loadGlobalStateOnStartup();
      
      // Enable animation on digivice
      let digivice = document.querySelector(".digivice-animation");
      if (digivice) {
        digivice.style.animation = "rotateDigivice 8s linear infinite";
      }
      
      // Check if any starter Digimon have been unlocked
      if (!gameState.permanentUpgrades.starter_agumon) {
        // If none, unlock Agumon as default
        gameState.permanentUpgrades.starter_agumon = true;
        saveGlobalState();
      }
      
      // Initialize round counter
      document.getElementById("round-display").textContent = gameState.roundNumber;
    };

    // Key bindings for mobile navigation
    document.addEventListener("keydown", function(event) {
      // ESC key closes overlays
      if (event.key === "Escape") {
        let overlays = document.querySelectorAll(".overlay");
        overlays.forEach(overlay => {
          if (overlay.style.display === "flex") {
            overlay.style.display = "none";
          }
        });
      }
    });

    /* W. ADDITIONAL GAMEPLAY FEATURES */
    // D-ARK (Scanner) Digivice special ability: chance for DE cards after turns
    function checkDARKDigiviceEffect() {
      if (gameState.activeDigivice !== "D-ARK") return;
      
      let level = gameState.digiviceLevels["D-ARK"] || 1;
      let chance = 20 + (level - 1) * 5; // 20% at level 1, increasing by 5% per level
      
      if (Math.random() * 100 < chance) {
        let card = getRandomDECard();
        if (card) {
          gameState.cardLibrary.push(card);
          logToBattle(`Your D-ARK Digivice detected a DE Card: ${card.name}!`);
        }
      }
    }

    // Handle Digimon evolution animation
    function playEvolutionAnimation(digimon, newForm) {
      // Create a modal for the evolution animation
      let modal = document.createElement("div");
      modal.style.position = "fixed";
      modal.style.top = "0";
      modal.style.left = "0";
      modal.style.width = "100%";
      modal.style.height = "100%";
      modal.style.backgroundColor = "rgba(0,0,0,0.8)";
      modal.style.display = "flex";
      modal.style.justifyContent = "center";
      modal.style.alignItems = "center";
      modal.style.zIndex = "1000";
      
      // Create animation container
      let container = document.createElement("div");
      container.style.position = "relative";
      container.style.width = "300px";
      container.style.height = "300px";
      container.style.overflow = "hidden";
      
      // Old form sprite
      let oldSprite = document.createElement("div");
      oldSprite.style.position = "absolute";
      oldSprite.style.top = "50%";
      oldSprite.style.left = "50%";
      oldSprite.style.transform = "translate(-50%, -50%)";
      oldSprite.style.width = "150px";
      oldSprite.style.height = "150px";
      oldSprite.style.backgroundImage = `url(${digimon.spriteUrl})`;
      oldSprite.style.backgroundSize = "contain";
      oldSprite.style.backgroundPosition = "center";
      oldSprite.style.backgroundRepeat = "no-repeat";
      oldSprite.style.animation = "evolveOut 2s forwards";
      
      // Evolution light
      let light = document.createElement("div");
      light.style.position = "absolute";
      light.style.top = "50%";
      light.style.left = "50%";
      light.style.transform = "translate(-50%, -50%)";
      light.style.width = "0";
      light.style.height = "0";
      light.style.backgroundColor = "#fff";
      light.style.borderRadius = "50%";
      light.style.opacity = "0";
      light.style.boxShadow = "0 0 50px 30px rgba(255, 255, 255, 0.8)";
      light.style.animation = "evolutionLight 2s forwards";
      
      // New form sprite
      let newSprite = document.createElement("div");
      newSprite.style.position = "absolute";
      newSprite.style.top = "50%";
      newSprite.style.left = "50%";
      newSprite.style.transform = "translate(-50%, -50%) scale(0)";
      newSprite.style.width = "180px";
      newSprite.style.height = "180px";
      newSprite.style.backgroundImage = `url(${newForm.spriteUrl})`;
      newSprite.style.backgroundSize = "contain";
      newSprite.style.backgroundPosition = "center";
      newSprite.style.backgroundRepeat = "no-repeat";
      newSprite.style.opacity = "0";
      newSprite.style.animation = "evolveIn 1.5s forwards 1.5s";
      
      // Evolution text
      let text = document.createElement("div");
      text.style.position = "absolute";
      text.style.bottom = "30px";
      text.style.left = "0";
      text.style.width = "100%";
      text.style.textAlign = "center";
      text.style.color = "#fff";
      text.style.fontSize = "20px";
      text.style.fontWeight = "bold";
      text.style.opacity = "0";
      text.style.textShadow = "0 0 10px rgba(255, 255, 255, 0.5)";
      text.style.animation = "fadeIn 0.5s forwards 3s";
      text.innerHTML = `${digimon.name} evolved to ${newForm.name}!`;
      
      // Add evolution animation styles
      let style = document.createElement("style");
      style.innerHTML = `
        @keyframes evolveOut {
          0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
          50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
          100% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
        }
        @keyframes evolutionLight {
          0% { opacity: 0; width: 0; height: 0; }
          50% { opacity: 1; width: 200px; height: 200px; }
          100% { opacity: 0; width: 300px; height: 300px; }
        }
        @keyframes evolveIn {
          0% { opacity: 0; transform: translate(-50%, -50%) scale(0); }
          50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
          100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }
        @keyframes fadeIn {
          0% { opacity: 0; }
          100% { opacity: 1; }
        }
      `;
      
      // Assemble everything
      container.appendChild(oldSprite);
      container.appendChild(light);
      container.appendChild(newSprite);
      container.appendChild(text);
      
      modal.appendChild(container);
      modal.appendChild(style);
      
      document.body.appendChild(modal);
      
      // Close the modal after animation completes
      setTimeout(() => {
        document.body.removeChild(modal);
      }, 5000);
    }

    /* Mobile Viewport Height Fix */
    function setVH() {
      let vh = window.innerHeight * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
    }
    
    // Set initial viewport height
    setVH();
    
    // Re-calculate on resize and orientation change
    window.addEventListener('resize', setVH);
    window.addEventListener('orientationchange', () => {
      setTimeout(setVH, 100);
    });

    /* Start the game! */
    console.log("Digimon Rogue-like RPG initialized!");
  </script>
</body>
</html>
